<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"node_modules_kamb-wc-widget-components_src_BlendedBackground_BlendedBackground.jsx.html":{"id":"node_modules_kamb-wc-widget-components_src_BlendedBackground_BlendedBackground.jsx.html","title":"Source: node_modules/kamb-wc-widget-components/src/BlendedBackground/BlendedBackground.jsx","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: node_modules/kamb-wc-widget-components/src/BlendedBackground/BlendedBackground.jsx import React, { Component } from 'react' import PropTypes from 'prop-types' import styles from './BlendedBackground.scss' import { coreLibrary } from 'kambi-widget-core-library' /** * Displays a background image which is blended with actual operator's color theme. */ class BlendedBackground extends Component { cssRender() { const style = this.props.blendWithOperatorColor ? { backgroundColor: 'currentColor'} : {} return ( &lt;div className={`${styles.backgroundContainer} KambiWidget-primary-color`} style={style} &gt; &lt;div className={styles.background} style={{ backgroundImage: `url(${this.props.backgroundUrl})`, backgroundRepeat: 'no-repeat', mixBlendMode: 'multiply', backgroundSize: 'cover', backgroundPosition: 'center' }} /&gt; &lt;/div&gt; ) } svgRender() { return ( &lt;div className={styles.backgroundContainer}&gt; &lt;svg xmlns=\"http://www.w3.org/2000/svg\" xmlnsXlink=\"http://www.w3.org/1999/xlink\" className={styles.background} &gt; &lt;defs&gt; &lt;filter id=\"filter\"&gt; &lt;feImage result=\"slide2\" x=\"0\" y=\"0\" width=\"100%\" preserveAspectRatio=\"xMidYMid slice\" xlinkHref={this.props.backgroundUrl} /&gt; { this.props.blendWithOperatorColor ? ( &lt;feBlend in2=\"SourceGraphic\" in=\"slide2\" mode=\"multiply\" /&gt; ) : null } &lt;/filter&gt; &lt;/defs&gt; &lt;rect className={`KambiWidget-primary-color ${styles.blendRect}`} x=\"0\" y=\"0\" filter='url(#filter)' width=\"100%\" height=\"100%\" /&gt; &lt;/svg&gt; &lt;/div&gt; ) } render() { /* as of firefox 55.0, firefox has a bug with the way we render the svg as a workaround we render the same thing using the new CSS mixBlendMode property. This property is not supported in IE so the main way to render this should still be using the SVG render */ if (coreLibrary.browser === 'firefox') { return this.cssRender() } else { return this.svgRender() } } } /** * @property backgroundUrl {String} provides path to backgroundImage * @property blendWidthOperatorColor {Boolean} determines if background should be blended with operator color. (Normally not wanted if providing own background image) */ BlendedBackground.propTypes = { backgroundUrl: PropTypes.string.isRequired, blendWithOperatorColor: PropTypes.bool } BlendedBackground.defaultProps = { blendWithOperatorColor: true, } export default BlendedBackground × Search results Close "},"node_modules_kamb-wc-widget-components_src_List_FixedList_FixedList.jsx.html":{"id":"node_modules_kamb-wc-widget-components_src_List_FixedList_FixedList.jsx.html","title":"Source: node_modules/kamb-wc-widget-components/src/List/FixedList/FixedList.jsx","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: node_modules/kamb-wc-widget-components/src/List/FixedList/FixedList.jsx import React, { Children, Component } from 'react'; import PropTypes from 'prop-types'; import styles from './FixedList.scss'; import ItemContainer from '../ItemContainer'; /** * Horizontal list component. Items will be stretched or shrunken to fit the container. * @memberOf widget-components */ class FixedList extends Component { /* * Constructs. * @param {object} props Component properties */ constructor(props) { super(props); this.state = { selected: props.selected }; } /* * Switches to given tab. * @param {number} idx Tab index */ onItemClick(idx) { if (this.props.onItemClick) { this.props.onItemClick(idx); } this.setState({ selected: idx }); } /* * Renders component. * @returns {XML} */ render() { return ( &lt;div className={styles.bar}&gt; {Children.map(this.props.children, (child, i) =&gt; this.props.renderItemContainer({ key: i, selected: this.state.selected == i, onClick: this.onItemClick.bind(this, i), children: child }))} &lt;/div&gt; ); } } /** * @callback FixedList_RenderItemContainer * @param {FixedList_RenderItemContainerArgs} args Contains properties which will control the container * @returns ReactElement * * @example &lt;caption&gt;Using custom item container&lt;/caption&gt; * ({selected, onClick, onWidth, children}) =&gt; * &lt;CustomItemContainer * selected={selected} * onClick={onClick} * onWidth={onWidth}&gt; * {children} * &lt;/CustomItemContainer&gt; * * @example &lt;caption&gt;Shorthand syntax can be used once function arguments and component properties names match.&lt;/caption&gt; * args =&gt; &lt;CustomItemContainer {...args}&gt;{args.children}&lt;/CustomItemContainer&gt; */ /** * @name FixedList_RenderItemContainerArgs * @property {boolean} selected Controls whether item should be rendered as currently selected or normally * @property {function} onClick Called once item has been clicked * @property {function} onWidth Called when item width is determined or has been changed * @property {ReactElement} children Item contents */ /** * @property [children] {ReactElement[]} Items list * @property [onItemClick] {function(number)} Item click handler. Called with item index argument. * @property [selected=0] {number} Initially selected item index * @property [renderItemContainer] {FixedList_RenderItemContainer} Function capable of rendering item container. Renders Kambi-styled item container by default. */ FixedList.propTypes = { children: PropTypes.node, onItemClick: PropTypes.func, selected: PropTypes.number, renderItemContainer: PropTypes.func }; FixedList.defaultProps = { selected: 0, renderItemContainer: args =&gt; &lt;ItemContainer {...args}&gt; {args.children} &lt;/ItemContainer&gt; }; export default FixedList; × Search results Close "},"node_modules_kamb-wc-widget-components_src_IconHeader_IconHeader.jsx.html":{"id":"node_modules_kamb-wc-widget-components_src_IconHeader_IconHeader.jsx.html","title":"Source: node_modules/kamb-wc-widget-components/src/IconHeader/IconHeader.jsx","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: node_modules/kamb-wc-widget-components/src/IconHeader/IconHeader.jsx import React from 'react'; import PropTypes from 'prop-types'; import styles from './IconHeader.scss'; const IconHeader = ({ title, subtitle, children, localStyles=[] }) =&gt; { const iconStyles = [styles.icon] if (localStyles.length &gt; 0) { localStyles.forEach(style =&gt; iconStyles.push(style)) } return ( &lt;header className={`KambiWidget-card-text-color KambiWidget-card-border-color KambiWidget-font ${styles.header}`}&gt; &lt;div className={iconStyles.join(' ')}&gt; {children} &lt;/div&gt; &lt;div className={styles.container}&gt; &lt;div className={styles.title} title={title}&gt;{title}&lt;/div&gt; &lt;div className={styles.subtitle} title={subtitle}&gt;{subtitle}&lt;/div&gt; &lt;/div&gt; &lt;/header&gt; ) } /** * @property [localStyles] {Array} Array of local styles as strings * @property [children] {ReactElement} Header's icon markup * @property title {string} Header's title * @property [subtitle] {string} Header's subtitle */ IconHeader.propTypes = { localStyles: PropTypes.arrayOf(PropTypes.string), children: PropTypes.node, title: PropTypes.string.isRequired, subtitle: PropTypes.string }; export default IconHeader; × Search results Close "},"src_coreLibrary.js.html":{"id":"src_coreLibrary.js.html","title":"Source: src/coreLibrary.js","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: src/coreLibrary.js import offeringModule from './Module/offeringModule' import statisticsModule from './Module/statisticsModule' import translationModule from './Module/translationModule' import utilModule from './Module/utilModule' import widgetModule from './Module/widgetModule' import updatesModule from './Module/updatesModule' import mockWidgetApi from './mockWidgetApi' import styles from './scss/core.scss' /** * Main module that holds the other modules as well as widget * related configurations * @module coreLibrary */ // checks status of a HTTP response and throws error if appropriate function checkStatus(response) { if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) { return response } else { var error = new Error(response.statusText) error.response = response throw error } } // checks browser type and version function checkBrowser() { var ua = window.navigator.userAgent var getFirstMatch = function(regex) { var match = ua.match(regex) return (match &amp;&amp; match.length &gt; 1 &amp;&amp; match[1]) || '' } var versionIdentifier = getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i) if (/android/i.test(ua)) { return { browser: 'android', browserVersion: versionIdentifier, } } else if (/(ipod|iphone|ipad)/i.test(ua)) { return { browser: 'ios', browserVersion: getFirstMatch(/(?:mxios)[\\s/](\\d+(?:\\.\\d+)+)/i), } } else if (/msie|trident/i.test(ua)) { return { browser: 'internet-explorer', browserVersion: getFirstMatch(/(?:msie |rv:)(\\d+(\\.\\d+)?)/i), } } else if (/chrome|crios|crmo/i.test(ua)) { return { browser: 'chrome', browserVersion: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i), } } else if (/safari|applewebkit/i.test(ua)) { return { browser: 'safari', browserVersion: versionIdentifier, } } else if (/chrome.+? edge/i.test(ua)) { return { browser: 'microsoft-edge', browserVersion: getFirstMatch(/edge\\/(\\d+(\\.\\d+)?)/i), } } else if (/firefox|iceweasel|fxios/i.test(ua)) { return { browser: 'firefox', browserVersion: getFirstMatch( /(?:firefox|iceweasel|fxios)[ /](\\d+(\\.\\d+)?)/i ), } } } /* * Downloads a resource from given URL. * @param {string} url URL of resource * @returns {Promise.&lt;{status: number, statusText: string, body: string}&gt;} */ function download(url) { return new Promise((resolve, reject) =&gt; { // fetch API is not supported in IE11 so we use // old-school XMLHttpRequest const xhr = new XMLHttpRequest() xhr.open('GET', url, true) xhr.onload = function() { const response = { status: xhr.status, statusText: xhr.statusText, body: 'response' in xhr ? xhr.response : xhr.responseText, } resolve(response) } xhr.onerror = () =&gt; reject(new TypeError('Network request failed')) xhr.ontimeout = () =&gt; reject(new TypeError('Network request failed')) xhr.send() }) } export default { /** * If true the coreLibrary has been initialized * @type {Boolean} */ initialized: false, /** * Name of the browser that is running the widget * @type {String} */ browser: checkBrowser().browser, /** * Browser version * @type {String} */ browserVersion: checkBrowser().browserVersion, /** * An array with the default classes that should be added to HTML tag */ kambiDefaultClasses: [ 'KambiWidget-card-text-color', 'KambiWidget-card-background-color', 'KambiWidget-font', ], /** * Config object. This data comes from the sportsbook and should not be manually changed. When in running the widget stand alone this values are retrieved from ./src/mockSetupData.json * @name config * @type {Object} * @property {String} apiBaseUrl url of the offering api to use * @property {Boolean} auth * @property {Number} channelId * @property {String} currency what currency to use * @property {String} customer the customer to use with the offering API * @property {String} device what kind of device does the user have. Possible values: 'desktop', 'mobile' * @property {String} locale locale of the user, example: 'en_GB', 'sv_SE' * @property {String} market market to use with the offering API. * @property {String} oddsFormat the odds format to show. Possible values: 'decimal', 'fractional', 'american'. To listen to changes to this value use eventsModule.subscribe('ODDS:FORMAT', eventHandlerFn); * @property {String} offering the offering to use with the offering API * @property {String} routeRoot * @property {Boolean} streamingAllowedForPlayer * @property {Number} client_id * @property {String} version */ _config: { apiBaseUrl: '', apiBaseUrls: {}, apiStatisticsBaseUrl: '', auth: false, channelId: 1, currency: 'EUR', customer: '', device: 'desktop', locale: 'en_GB', market: 'GB', oddsFormat: 'decimal', offering: '', routeRoot: '', streamingAllowedForPlayer: true, client_id: 2, version: 'v2', }, get config() { return this._config }, set config(config) { for (var i in config) { if (config.hasOwnProperty(i) &amp;&amp; this._config.hasOwnProperty(i)) { this._config[i] = config[i] } } // Make sure that the routeRoot is not null or undefined if (this._config.routeRoot == null) { this._config.routeRoot = '' } else if ( this._config.routeRoot.length &gt; 0 &amp;&amp; this._config.routeRoot.slice(-1) !== '/' ) { // If the routeRoot is not empty we need to make sure it has a trailing slash this._config.routeRoot += '/' } }, /** * The odds format for the bets shown in the widget * @private */ _oddsFormat: null, set oddsFormat(format) { this._oddsFormat = format }, get oddsFormat() { return this._oddsFormat }, /** * default args object * @private */ _defaultArgs: {}, get defaultArgs() { return this._defaultArgs }, set defaultArgs(defaultArgs) { this._defaultArgs = Object.assign(defaultArgs, { onHeightChange: function() {}, onWidgetRemoved: function() {}, onWidgetLoaded: function() {}, }) }, /** * args object for the widget, merges the default args provided by coreLibrary.init() with the ones that come from the sportsbook. There are some pre-defined arguments that all widgets accept, but most of them are widget-defined. * @property {String} widgetTrackingName Sets widget tracking name for analytics purposes. This tracking name is used for calls to add bets to the betslip * @property {String} customCssUrl URL to a CSS file to add to the page, expressions like \"{customer}\" are replaced with their values in coreLibrary.config. This is useful to load different stylesheets based on operator name. Example: Say coreLibrary.config.customer is 'kambi', then if this argument was set: { customCssUrl: \"https://someurl.com/customcss/{customer}/style.css\" } It would load this CSS file and add it to the page: https://someurl.com/customcss/kambi/style.css * @property {String} customCssUrlFallback fallback if the fetching of customCssUrl fails * @property {Function} onHeightChange Callback called when an embedded widget height changes (by calling either widgetModule.setWidgetHeight or widgetModule.adaptWidgetHeight) * @property {Function} onWidgetRemoved Callback called when an widget removes itself (by calling widgetModule.removeWidget) * @property {Function} onWidgetLoaded Callback called when an widget finishes loading. This needs to be called by the widget itself after rendering its content * @property {Function} onWidgetNavigateClient Callback called when an widget wants to navigate to another page. In embedded mode the widget will NOT call the WidgetAPI.navigateClient, instead it will call this method with the path of the page. Second parameter is coreLibrary.args.widgetTrackingName * @property {Array&lt;Object&gt;} conditionalArgs Optional, specify arguments to be applied based on some condition based in the values inside coreLibrary.config or coreLibrary.pageInfo * @property {String|null} widgetTrackingName navigateClient Optional, callback called when the widget tries to perform internal Kambi Sportsbook navigation example: conditionalArgs: [ // if coreLibrary.config.currency is 'EUR' apply { euro: true, dollars: false } to the arguments { config: { currency: 'EUR' }, args: { euro: true, dollars: false } }, // if market is 'IT' AND offering is 'IT' apply { italian: true } to the arguments { config: { market: 'IT', offering: 'IT' }, args: { italian: true } }, ] * @name args */ _args: null, get args() { return this._args }, set args(args) { args = Object.assign({}, this.defaultArgs, args) // Handling conditionalArgs if (args.conditionalArgs != null) { args.conditionalArgs.forEach(carg =&gt; { var apply = true if (carg.clientConfig != null) { Object.keys(carg.clientConfig).forEach(key =&gt; { if (this.config[key] !== carg.clientConfig[key]) { apply = false } }) } if (carg.pageInfo != null) { Object.keys(carg.pageInfo).forEach(key =&gt; { if (this.pageInfo[key] !== carg.pageInfo[key]) { apply = false } }) } if (apply) { console.log('Applying conditional arguments:') console.log(carg.args) args = Object.assign(args, carg.args) } }) } this._args = args }, /** * Information about the page that the widget is being loaded from * @name pageInfo * @type {Object} * @property {Array(String)} leaguePaths array with league paths. Example:['football/england/premier_league'] * @property {String} pageParam parameter for this page. For a page of type 'filter' an example would be 'football/england/premier_league' * @property {String} pageTrackingPath the path in the url for this page. For example: '/filter/football/england/premier_league' * @property {String} pageType type of the page, examples: 'home', 'filter' */ _pageInfo: { leaguePaths: [], pageParam: '', pageTrackingPath: '', pageType: '', }, get pageInfo() { return this._pageInfo }, set pageInfo(pageInfo) { // Check if the last character in the pageParam property is a slash, if not add it so we can use this property in filter requests if ( pageInfo.pageType === 'filter' &amp;&amp; pageInfo.pageParam.substr(-1) !== '/' ) { pageInfo.pageParam += '/' } this._pageInfo = pageInfo }, /** * Element that should be used as root to render the widget from. Widgets should render only inside this element * @name rootElement * @type {HTMLElement} */ rootElement: null, /** * Element that the widget will be placed inside of when running in embedded mode * @name rootElement * @type {HTMLElement} * @private */ embeddedElement: null, /** * Versions of the API provided by the sportsbook * @name apiVersions * @type {Object} * @property {String} client * @property {String} libs * @property {String} wapi */ _apiVersions: { client: '', libs: '', wapi: '', }, get apiVersions() { return this._apiVersions }, set apiVersions(versions) { this._apiVersions = versions }, /** * The name sent to Kambi API for analytics data collection */ _widgetTrackingName: null, set widgetTrackingName(name) { if (name == null) { name = null // transforms undefined to null } this._widgetTrackingName = name }, get widgetTrackingName() { return this._widgetTrackingName }, /** * Promise that is resolved when all the CSS has finished loading * @type Promise */ cssLoadedPromise: null, /** * a direct reference to the Kambi's WidgetApi (wapi) * @type Object */ widgetApi: null, /** * Methods returned by the widget when it's function is called in Embedded mode * by adding more methods here the widget can set up communication with the rest of the page */ embeddedMethods: { removeWidget: widgetModule.removeWidget.bind(widgetModule), }, /** * Initializes the Kambi api * Uses ./src/mockSetupData.json as coreLibrary.configs if not loaded inside the sportsbook (ie opened the widget directly). * @param {Object} defaultArgs arguments to be used if they are not provided by the sportsbook * @returns {Promise} resolved when everything is ready. If an error happens during fetching the error can be catched in a .catch() function */ init(defaultArgs) { this.defaultArgs = defaultArgs const EMBEDDED = process.env.EMBEDDED === 'true' return new Promise((resolve, reject) =&gt; { // applies the setup data and sets up the CSS and translations var applySetupData = setupData =&gt; { this.oddsFormat = setupData.clientConfig.oddsFormat this.config = setupData.clientConfig this.pageInfo = setupData.pageInfo this.apiVersions = setupData.versions this.args = setupData.arguments if (!EMBEDDED) { // if embedded the widget will assume that operator CSS is included by whoever is embedding it this.injectOperatorCss(this.config.customer, this.config.offering) const body = document.body this.kambiDefaultClasses.map(cssClass =&gt; { body.classList.add(cssClass) }) } this.injectCustomCss( this.args.customCssUrl, this.args.customCssUrlFallback ) this.widgetTrackingName = this.args.widgetTrackingName this.initialized = true resolve() } if (EMBEDDED) { if (!window.gmWidgets) { window.gmWidgets = {} } window.gmWidgets[process.env.WIDGET_NAME] = ( container, wapi, clientConfig, args ) =&gt; { if (container == null) { throw new Error('Container not provided. Please send a HTMLElement') } if (wapi == null) { throw new Error( 'Wapi not provided. Please send a reference to the Kambi Widget API' ) } if (clientConfig == null) { throw new Error( 'clientConfig not provided. Please send an object with client config data' ) } this.widgetApi = wapi this.embeddedElement = container this.rootElement = document.createElement('div') this.rootElement.className += ` ${[styles.rootElement].join(' ')}` this.embeddedElement.className += ` ${[ styles.rootElementEmbedded, ].join(' ')}` this.embeddedElement.appendChild(this.rootElement) if (window.KambiWidget.receiveResponse == null) { window.KambiWidget.receiveResponse = function() {} } const previousResponseHandler = window.KambiWidget.receiveResponse window.KambiWidget.receiveResponse = (dataObject, wapi) =&gt; { previousResponseHandler(dataObject, wapi) // calls any handlers from other widgets or the main page widgetModule.handleResponse(dataObject) updatesModule.handleResponse(dataObject) } widgetModule.requestBetslipOutcomes() // we intentionally do not call requestOddsFormat here, this method should be called exactly once per page so it should be called by whoever is calling this widget. //widgetModule.requestOddsFormat() applySetupData({ clientConfig: Object.assign({}, clientConfig), arguments: Object.assign({}, args), pageInfo: {}, versions: {}, }) return this.embeddedMethods } } else { document.documentElement.className += ` ${styles.notEmbedded}` this.rootElement = document.createElement('div') this.rootElement.className += ` ${styles.rootElement}` document.body.appendChild(this.rootElement) if (window.self === window.top) { // For development purposes we might want to load a widget on its own so we check if we are in an iframe, if not then load a mocked version of the setupData this.widgetApi = mockWidgetApi console.warn( window.location.host + window.location.pathname + ' is being loaded as stand-alone' ) this.fetchMockSetupData() .then(data =&gt; applySetupData(data)) .catch(err =&gt; reject(err)) } else { window.KambiWidget.apiReady = wapi =&gt; { this.widgetApi = wapi // Request the setupData from the widget api widgetModule.requestSetup(setupData =&gt; { setupData.arguments = setupData.arguments ? setupData.arguments : {} const args = setupData.arguments // Request the outcomes from the betslip so we can update our widget, also sets up a subscription for future betslip updates widgetModule.requestBetslipOutcomes() // Request the odds format that is set in the sportsbook, this also sets up a subscription for future odds format changes widgetModule.requestOddsFormat() // Check if the args contains mockSetupData key if (args.mockSetupData == null) { applySetupData(setupData) } else if (typeof args.mockSetupData === 'string') { this.fetchMockSetupData(args.mockSetupData) .then(data =&gt; { delete args.mockSetupData data.arguments = Object.assign(data.arguments, args) applySetupData(data) }) .catch(err =&gt; reject(err)) } else { applySetupData(args.mockSetupData) } }) } // Setup the response handler for the widget api window.KambiWidget.receiveResponse = dataObject =&gt; { widgetModule.handleResponse(dataObject) updatesModule.handleResponse(dataObject) } } } }) }, /** * Fetches a mockSetupData.json file used to initialise a widget with specific configurations * * @param path {string} [path='mockSetupData.json'] * @returns {object} mockSetupData * @private */ fetchMockSetupData(path = 'mockSetupData.json') { return this.getData(path) .then(mockSetupData =&gt; { console.debug('Loaded mock setup data') console.debug(mockSetupData) return mockSetupData }) .catch(error =&gt; { console.debug('Failed to fetch mockSetupData') console.trace(error) return error }) }, /** * Dynamically creates a style tag and returns it * @param id {String} the id to add to the tag * @param content {String} text content of the tag (the styles) * @returns HTMLElement the tag created * @private */ createStyleTag(id, url) { const tag = document.createElement('link') tag.setAttribute('id', id) tag.setAttribute('rel', 'stylesheet') tag.setAttribute('type', 'text/css') tag.setAttribute('href', url) return tag }, /** * Injects operator specific CSS based on version defined in constans.js, * customer and offering * @param customer {String} * @param offering {String} * @private */ injectOperatorCss(customer, offering) { const url = '//c3-static.kambi.com/sb-mobileclient/widget-api/' + process.env.WIDGET_CSS_VERSION + '/resources/css/' + customer + '/' + offering + '/widgets.css' const tag = this.createStyleTag('operator-css', url) const head = document.head // opereator CSS should be the FIRST CSS in the page head.insertBefore(tag, head.firstChild) }, /** * Injects stylesheet based on configuration parameters (coreLibrary.config) * Replaces expressions like \"{customer}\" in the strings provided * @param customCssUrl {String} * @param customCssUrlFallback {String} Fallback if the first URL fetch fails * @returns {Promise} when resolved the stylesheet has been successfully added to the page * @private */ injectCustomCss(customCssUrl, customCssUrlFallback) { if (customCssUrl == null) { return } if (customCssUrlFallback == null) { customCssUrlFallback = '' } customCssUrl = utilModule.replaceConfigParameters(customCssUrl) customCssUrlFallback = utilModule.replaceConfigParameters( customCssUrlFallback ) const appendToHead = url =&gt; { const tag = this.createStyleTag('custom-css', url) const head = document.head // custom CSS should be the LAST CSS in the page head.insertBefore(tag, null) } // TODO instead of doing an extra request maybe try to add an // event listener to the &lt;link&gt; tag to see if the file exists or not // see http://stackoverflow.com/questions/10537039/how-to-determine-if-css-has-been-loaded return this.getFile(customCssUrl) .then(response =&gt; { appendToHead(customCssUrl) return response }) .catch(error =&gt; { if (customCssUrlFallback !== '') { console.debug('Error fetching custom css, using fallback') appendToHead(customCssUrlFallback) } else { console.debug('Error fetching custom css, no fallback present') return error } }) }, /** * Makes a AJAX request and parses its response as JSON * @param {String} url * @returns {Promise} resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function */ getData(url) { return download(url) .then(checkStatus) .then(response =&gt; { return JSON.parse(response.body) }) .catch(error =&gt; { console.debug('Error fetching data') console.trace(error) throw error }) }, /** * Makes a AJAX request and parses its response as text * @param {String} url * @returns {Promise} resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function */ getFile(url) { return download(url) .then(checkStatus) .then(response =&gt; response.body) .catch(error =&gt; { console.debug('Error fetching file') console.trace(error) throw error }) }, } × Search results Close "},"src_Module_offeringModule.js.html":{"id":"src_Module_offeringModule.js.html","title":"Source: src/Module/offeringModule.js","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: src/Module/offeringModule.js import coreLibrary from '../coreLibrary' /** * Module with methods to request data from the offering API * The offering API has information concerning events (matches, competations) and their respective betoffers as well as live data if available * All methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure * @module offeringModule */ export default { /** * Get group events * @param {number|string} groupId Group id * @returns {Promise} */ getGroupEvents(groupId) { var requesPath = '/event/group/' + groupId + '.json' return this.doRequest(requesPath) }, /** * Get group information. * @param {Number|String} groupId Group id * @returns {Promise} */ getGroup(groupId) { var requesPath = '/group/' + groupId + '.json' return this.doRequest(requesPath) }, /** * Get events by filter, only returns the main betoffer for the event. To get all betoffers use getEvent() or getLiveEvent() * @param {String} filter Filter string, eg: football * @param {Object} params Request relevant parameters * @returns {Promise} */ getEventsByFilter(filter, params) { // Todo: Update this method once documentation is available filter = filter.replace(/^#?\\/?/, '') // removes #/ at the start of the string if present var requestPath = '/listView/' + filter return this.doRequest(requestPath, params, 'v3') }, /** * Normalizes v2 api betoffers * @param {Object} betOffer Betoffer object we get from api * @private */ adaptV2BetOffer(betOffer) { if (betOffer.suspended === true) { betOffer.open = false } }, /** * Normalizes the v2 api response * @param {Object} liveData Livedata object we get from api * @private */ adaptV2LiveData(liveData) { if (liveData != null &amp;&amp; liveData.statistics != null) { var statistics = liveData.statistics if (statistics.sets != null) { statistics.setBasedStats = statistics.sets delete statistics.sets } if (statistics.football != null) { statistics.footballStats = statistics.football delete statistics.football } } }, /** * Normalizes the v2 event object * @private */ adaptV2Event(event) { // v3 and v2 event objects are almost the same // only a few attributes we don't use are different }, /** * Get live event data only, eg: match statistics, score, macthClock * @param {Number|String} eventId The event id we need to fetch * @returns {Promise} * @private */ getLiveEventData(eventId) { var requestPath = '/event/' + eventId + '/livedata.json' return this.doRequest(requestPath, null, null, true).then(res =&gt; { this.adaptV2LiveData(res) return res }) }, /** * Get all live events, only returns the main betoffer for the event. To get all betoffers use getEvent() or getLiveEvent() * @returns {Promise} */ getLiveEvents() { var requestPath = '/event/live/open.json' return this.doRequest(requestPath, null, null, true).then(res =&gt; { if (res.error != null) { return res } var events = res.liveEvents res.events = events res.events.forEach(this.adaptV2Event) delete res.liveEvents delete res.group events.forEach(e =&gt; { e.betOffers = [] if (e.mainBetOffer != null) { this.adaptV2BetOffer(e.mainBetOffer) e.betOffers.push(e.mainBetOffer) delete e.mainBetOffer } this.adaptV2LiveData(e.liveData) }) return res }) }, /** * Returns a live event * @param {Number|String} eventId The event id we need to fetch * @returns {Promise} */ getLiveEvent(eventId) { var requestPath = '/betoffer/live/event/' + eventId + '.json' return this.doRequest(requestPath, null, null, true).then(res =&gt; { res.betOffers = res.betoffers delete res.betoffers res.betOffers.forEach(this.adaptV2BetOffer) res.event = res.events[0] this.adaptV2Event(res.event) delete res.events return res }) }, /** * Get live events by filter, only returns the main betoffer for the event. To get all betoffers use getEvent() or getLiveEvent() * @param {String} filter Filter string * @returns {Promise} */ getLiveEventsByFilter(filter) { // Todo: implement a filter request when the offering API supports it filter = filter.replace(/\\/$/, '') var filterTerms = filter.split('/') filterTerms = filterTerms.slice(0, 3) var requestPath = '/listView/all/all/all/all/in-play/' return this.doRequest(requestPath, null, 'v3').then(response =&gt; { var result = { events: [], }, i = 0, len = response.events.length for (; i &lt; len; ++i) { var j = 0, termLen = response.events[i].event.path.length, addEvent = true if (termLen &gt; filterTerms.length) { termLen = filterTerms.length } for (; j &lt; termLen; ++j) { if ( filterTerms[j] !== 'all' &amp;&amp; response.events[i].event.path[j].termKey !== filterTerms[j] ) { addEvent = false } } if (addEvent) { result.events.push(response.events[i]) } } return result }) }, /** * Requests and event from api * @param {String} eventId The event id we need to fetch * @returns {Promise} */ getEvent(eventId) { return this.doRequest('/betoffer/event/' + eventId + '.json').then(res =&gt; { res.betOffers = res.betoffers delete res.betoffers res.betOffers.forEach(this.adaptV2BetOffer) res.event = res.events[0] this.adaptV2Event(res.event) delete res.events return res }) }, /** * Request the highlight resource which is what is shown under the \"Popular\" section in the Sportsbook * @returns {Promise} */ getHighlight() { return this.doRequest('/group/highlight.json').then(highlights =&gt; { // sorting based on sortOrder if (Array.isArray(highlights.groups)) { highlights.groups.sort((a, b) =&gt; { if (parseInt(a.sortOrder, 10) &gt; parseInt(b.sortOrder, 10)) { return 1 } if (parseInt(a.sortOrder, 10) &lt; parseInt(b.sortOrder, 10)) { return -1 } return 0 }) } return highlights }) }, /** * Makes a request to provided path setting the appropriated URL parameters. Usually this method should not be called directly, unless you want to access an endpoint that is not available in the other methods The final url looks like: coreLibrary.config.apiBaseUrl + version + coreLibrary.config.offering + requestPath Example (same as calling offeringModule.getLiveEvents() but forcing to use Portugal Portuguese locale) doRequest('/event/live/open.json' { lang: 'pt_PT' }); this call would fetch this url: https://api.kambi.com/offering/api/v2/kambi/event/live/open.json?lang=pt_PT&amp;market=kambi&amp;client_id=2&amp;include=&amp;betOffers=COMBINED&amp;categoryGroup=COMBINED&amp;displayDefault=true&amp;nocache=1476973932524 * @param {string} requestPath the path to the request * @param {object} params params to use, can override the parameters this method usually sets * @param {number|string} version which version of the API to use. Some endpoints are 'v2' and some are 'v3' * @param {boolean} noCache if true will add a cache-busting URL parameter. Defaults to true * @returns {Promise} */ doRequest(requestPath, params, version, noCache) { var config = coreLibrary.config if (config.offering == null) { return Promise.reject( new Error( 'The offering has not been set, is the right widget api version loaded?' ) ) } else { var apiUrl = config.apiBaseUrl.replace( '{apiVersion}', version != null ? version : config.version ) var requestUrl = apiUrl + config.offering + requestPath var overrideParams = params || {} var requestParams = { lang: overrideParams.locale || config.locale, market: overrideParams.market || config.market, client_id: overrideParams.client_id || config.client_id, include: overrideParams.include || '', betOffers: overrideParams.betOffers || 'COMBINED', categoryGroup: overrideParams.categoryGroup || 'COMBINED', displayDefault: overrideParams.displayDefault || true, } if (noCache === true) { requestParams.nocache = Date.now() } requestUrl += '?' + Object.keys(requestParams) .map(function(k) { return ( encodeURIComponent(k) + '=' + encodeURIComponent(requestParams[k]) ) }) .join('&amp;') return coreLibrary.getData(requestUrl) } }, } × Search results Close "},"src_Module_statisticsModule.js.html":{"id":"src_Module_statisticsModule.js.html","title":"Source: src/Module/statisticsModule.js","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: src/Module/statisticsModule.js import coreLibrary from '../coreLibrary' /** * Module to access statistics API * The statistics API has information concerning historical data of events (matches, competitions) * All methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure * @module statisticsModule */ export default { /** * Requests league table statistics data from api. * @param {String} filter a filter string to a competition. Example 'football/england/premier_league' * @returns {Promise} */ getLeagueTableStatistics(filter) { // Remove url parameters from filter filter = filter.match(/[^?]*/)[0] // Removing trailing and starting slashes if present if (filter[filter.length - 1] === '/') { filter = filter.slice(0, -1) } if (filter[0] === '/') { filter = filter.slice(1) } return this.doRequest('/leaguetable/' + filter + '.json') }, /** * Requests H2H statistics data from api. * @param {String|Number} eventId id of a match * @returns {Promise} */ getHeadToHeadStatistics(eventId) { return this.doRequest('/h2h/event/' + eventId + '.json') }, /** * Requests TPI statistics data from api. * @param {String|Number} eventId id of a match * @returns {Promise} */ getTeamPerformanceStatistics(eventId) { return this.doRequest('/tpi/event/' + eventId + '.json') }, /** * Performs the statistics API requests * @param {String} path path of the desired resource, for example /leaguetable/football/england/premier_league.json' * @returns {Promise} */ doRequest(path) { if (path.charAt(0) !== '/') { path += '/' } return coreLibrary.getData( coreLibrary.config.apiStatisticsBaseUrl + coreLibrary.config.offering + path + `?lang=${coreLibrary.config.locale}&amp;market=${coreLibrary.config.market}` ) }, } × Search results Close "},"src_Module_translationModule.js.html":{"id":"src_Module_translationModule.js.html","title":"Source: src/Module/translationModule.js","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: src/Module/translationModule.js import coreLibrary from '../coreLibrary' const widgetName = process.env.WIDGET_NAME /** * Module with internationalization methods * Provides a very simple internationalization mechanism * that is not relient in any library. * The loading of the right internationalization JSON file is handled automatically * @module translationModule */ export default { /** * Returns translated string based of a provided key. * @param {String} key Key to fetch translation for * @param {...String} args arguments to replace inside the translated string * @example * en_GB.json: * { \"welcomeUserToPlace\": \"Welcome {0} to {1}\" } * Javascript: * getTranslation('welcomeUserToPlace', 'Daniel', 'Stadium') =&gt; 'Welcome Daniel to Stadium' * @returns {String} the localized string */ getTranslation: function(key, ...args) { const locale = coreLibrary.config.locale const kambiI18n = window.gmWidgetsI18n[widgetName] if (kambiI18n == null || locale == null || locale.length != 5) { return key } let strings = null if (kambiI18n[locale] == null) { // falling back to another locale, trying one that matches the first language name, then falling back to en_GB const language = locale.split('_')[0] if (language.length !== 2) { return key } if (language === 'en' &amp;&amp; kambiI18n.en_GB != null) { strings = kambiI18n.en_GB } else { const locales = Object.keys(kambiI18n).sort() for (let i = 0; i &lt; locales.length; i++) { if (locales[i].split('_')[0] === language) { strings = kambiI18n[locales[i]] break } } } } else { strings = kambiI18n[locale] } if (strings == null) { if (kambiI18n.en_GB != null) { strings = kambiI18n.en_GB } else { return key } } var str = strings[key] if (str == null) { return key } for (let i = 0; i &lt; args.length; i++) { var replacement = args[i] || '' str = str.replace('{' + i + '}', replacement) } return str }, } × Search results Close "},"src_Module_updatesModule.js.html":{"id":"src_Module_updatesModule.js.html","title":"Source: src/Module/updatesModule.js","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: src/Module/updatesModule.js import coreLibrary from '../coreLibrary' const customTypeSeparator = '-' /** * Module with methods to set up subscription for different kinds of updates (betoffer data, odds format change and so on) * @module updatesModule */ const updatesModule = { get api() { return coreLibrary.widgetApi }, /* The final callbacks object structure should look like this: { BetslipOutcomes: [cb1, cb2, cb3, ...] ODDS_FORMAT: [cb1, cb2, cb3, ...] BASIC: { [eventId]: [cb1, cb2, cb3, ...], ... }, SCORE: { [eventId]: [cb1, cb2, cb3, ...], ... }, BET_OFFERS-LIVE-ALL: { [eventId]: [cb1, cb2, cb3, ...] } }, BET_OFFERS-PRE_MATCH-ALL: { [eventId]: [cb1, cb2, cb3, ...] }, BET_OFFERS-LIVE-MAIN: { [eventId]: [cb1, cb2, cb3, ...] } }, BET_OFFERS-PRE_MATCH-MAIN: { [eventId]: [cb1, cb2, cb3, ...] }, } */ callbacks: {}, _getCallbackType(type, context, mainOnly) { if (type === this.api.EVENT_INFO_TYPES.BET_OFFERS) { return ( type + customTypeSeparator + context + customTypeSeparator + (mainOnly ? 'MAIN' : 'ALL') ) } else { return type } }, /* * Handles responses from the Widget API and calls the correct callbacks */ handleResponse(response) { const data = response.data if (response.type === this.api.BETSLIP_OUTCOMES) { if (this.callbacks[this.api.BETSLIP_OUTCOMES] == null) { this.callbacks[this.api.BETSLIP_OUTCOMES] = [] } this.callbacks[this.api.BETSLIP_OUTCOMES].forEach(cb =&gt; { cb(data) }) return } else if (response.type === this.api.CLIENT_ODDS_FORMAT) { if (this.callbacks[this.api.CLIENT_ODDS_FORMAT] == null) { this.callbacks[this.api.CLIENT_ODDS_FORMAT] = [] } this.callbacks[this.api.CLIENT_ODDS_FORMAT].forEach(cb =&gt; { cb(data) }) return } else if (response.type === this.api.EVENT_INFO) { let cbs = this.callbacks[ this._getCallbackType(data.info, data.context, data.mainOnly) ] if (cbs != null &amp;&amp; cbs[data.id] != null) { cbs[data.id].forEach(cb =&gt; { cb(data) }) } } }, /* * Adds a callback to the callbacks object */ _addCallback(type, eventId, cb, context, mainOnly = false) { const cbs = updatesModule.callbacks if (cb == null || eventId == null || type == null) { console.error('Missing argument for subscription') return } if ( context != null &amp;&amp; context !== this.api.EVENT_INFO_CONTEXT.LIVE &amp;&amp; context !== this.api.EVENT_INFO_CONTEXT.PRE_MATCH ) { console.error('eventUpdatesModule invalid context value') return } type = this._getCallbackType(type, context, mainOnly) if (cbs[type] == null) { cbs[type] = {} } if (cbs[type][eventId] == null) { cbs[type][eventId] = [] } cbs[type][eventId].push(cb) }, subscribe: { get api() { return coreLibrary.widgetApi }, /* IE11 is throwing erros when subscribing to EVENT_INFO in the widget api. This returns false for Edge */ _isIE11() { return navigator.appName.indexOf('Trident') !== -1 }, /** * Subscription that is triggered when there is any change to the betslip * @param {Function} callback Callback to be called when receiving new data */ betslipOutcomes(callback) { const cbs = updatesModule.callbacks if (cbs[this.api.BETSLIP_OUTCOMES] == null) { cbs[this.api.BETSLIP_OUTCOMES] = [] } cbs[this.api.BETSLIP_OUTCOMES].push(callback) }, /** * Subscription that is triggered when the odds format (decimal, fractional, american) changes * @param {Function} callback Callback to be called when receiving new data */ oddsFormat(callback) { const cbs = updatesModule.callbacks if (cbs[this.api.CLIENT_ODDS_FORMAT] == null) { cbs[this.api.CLIENT_ODDS_FORMAT] = [] } cbs[this.api.CLIENT_ODDS_FORMAT].push(callback) this.oddsFormatSubscribedTo = true }, /** * Subscription that is triggered when the basic information about an event changes * @param {Number} eventId the id of the event to listen for updates * @param {Function} callback Callback to be called when receiving new data */ basicInfo(eventId, callback) { if (this._isIE11()) { return } const info = this.api.EVENT_INFO_TYPES.BASIC this.api.request(this.api.EVENT_INFO, { id: eventId, info, }) updatesModule._addCallback(info, eventId, callback) }, /** * Subscription that is triggered when the scoreboard information about an event changes * @param {Number} eventId the id of the event to listen for updates * @param {Function} callback Callback to be called when receiving new data */ score(eventId, callback) { if (this._isIE11()) { return } const info = this.api.EVENT_INFO_TYPES.SCORE this.api.request(this.api.EVENT_INFO, { id: eventId, info, }) updatesModule._addCallback(info, eventId, callback) }, /** * Subscription that is triggered when the any of the prematch betoffers of an event change. This can be triggered several times per second * @param {Number} eventId the id of the event to listen for updates * @param {Function} callback Callback to be called when receiving new data */ allPreMatchBetoffers(eventId, callback) { if (this._isIE11()) { return } const info = this.api.EVENT_INFO_TYPES.BET_OFFERS const context = this.api.EVENT_INFO_CONTEXT.PRE_MATCH this.api.request(this.api.EVENT_INFO, { id: eventId, info, context, }) updatesModule._addCallback(info, eventId, callback, context, false) }, /** * Subscription that is triggered when the any of the prematch live of an event change. This can be triggered several times per second * @param {Number} eventId the id of the event to listen for updates * @param {Function} callback Callback to be called when receiving new data */ allLiveBetoffers(eventId, callback) { if (this._isIE11()) { return } const info = this.api.EVENT_INFO_TYPES.BET_OFFERS const context = this.api.EVENT_INFO_CONTEXT.LIVE this.api.request(this.api.EVENT_INFO, { id: eventId, info, context, }) updatesModule._addCallback(info, eventId, callback, context, false) }, /** * Subscription that is triggered when the any of the main (betoffer.main === true) prematch betoffers of an event change. This can be triggered several times per second * @param {Number} eventId the id of the event to listen for updates * @param {Function} callback Callback to be called when receiving new data */ mainPreMatchBetoffers(eventId, callback) { if (this._isIE11()) { return } const info = this.api.EVENT_INFO_TYPES.BET_OFFERS const context = this.api.EVENT_INFO_CONTEXT.PRE_MATCH this.api.request(this.api.EVENT_INFO, { id: eventId, info, context, mainOnly: true, }) updatesModule._addCallback(info, eventId, callback, context, true) }, /** * Subscription that is triggered when the any of the main (betoffer.main === true) live betoffers of an event change. This can be triggered several times per second * @param {Number} eventId the id of the event to listen for updates * @param {Function} callback Callback to be called when receiving new data */ mainLiveBetoffers(eventId, callback) { if (this._isIE11()) { return } const info = this.api.EVENT_INFO_TYPES.BET_OFFERS const context = this.api.EVENT_INFO_CONTEXT.LIVE this.api.request(this.api.EVENT_INFO, { id: eventId, info, context, mainOnly: true, }) updatesModule._addCallback(info, eventId, callback, context, true) }, }, /** * Unsubscribes the callback passed. The function will be unsubscribed from all its subscriptions in case the same callback was passed to more than one subscribe call * @param {Function} callback callback to be unsubscribed * @returns {Boolean} returns true if the function was unsubscribed from at least one subscription */ unsubscribe(callback) { let unsubscribed = false const cbs = updatesModule.callbacks Object.keys(cbs).forEach(type =&gt; { if (Array.isArray(cbs[type])) { const idx = cbs[type].indexOf(callback) if (idx !== -1) { cbs[type].splice(idx, 1) unsubscribed = true } } else { Object.keys(cbs[type]).forEach(eventId =&gt; { const idx = cbs[type][eventId].indexOf(callback) if (idx !== -1) { cbs[type][eventId].splice(idx, 1) unsubscribed = true } if (cbs[type][eventId].length === 0) { const [realType, context, main] = type.split(customTypeSeparator) const mainOnly = main === 'MAIN' const unsubObj = { id: eventId, info: type, } if (context != null) { unsubObj.context = context } if (mainOnly) { unsubObj.mainOnly = true } this.api.request(this.api.EVENT_INFO_UNSUBSCRIBE, unsubObj) delete cbs[type][eventId] } }) } }) return unsubscribed }, } export default updatesModule // code to test this module // coreLibrary.init({}).then(() =&gt; { // widgetModule.setWidgetHeight(300) // const eventId = 1004530932 // eventUpdatesModule.subscribe.mainLiveBetoffers(eventId, data =&gt; { // console.log('mainLiveBetoffers') // console.log(data) // }) // eventUpdatesModule.subscribe.allLiveBetoffers(eventId, data =&gt; { // console.log('allLiveBetoffers') // console.log(data) // }) // eventUpdatesModule.subscribe.mainPreMatchBetoffers(eventId, data =&gt; { // console.log('mainPreMatchBetoffers') // console.log(data) // }) // eventUpdatesModule.subscribe.allPreMatchBetoffers(eventId, data =&gt; { // console.log('allPreMatchBetoffers') // console.log(data) // }) // eventUpdatesModule.subscribe.score(eventId, data =&gt; { // console.log('score') // console.log(data) // }) // eventUpdatesModule.subscribe.basicInfo(eventId, data =&gt; { // console.log('basicInfo') // console.log(data) // }) // offeringModule // .getLiveEvent(eventId) // .catch(() =&gt; { // return offeringModule.getEvent(eventId) // }) // .then(data =&gt; { // let ev = data.event // let bo = data.betOffers.find(bo =&gt; bo.main) // ReactDOM.render( // &lt;div&gt; // &lt;OutcomeButton outcome={bo.outcomes[0]} event={ev} /&gt; // {/* &lt;OutcomeButton outcome={bo.outcomes[1]} event={ev} /&gt; */} // &lt;/div&gt;, // document.getElementById('root') // ) // }) // }) × Search results Close "},"src_Module_utilModule.js.html":{"id":"src_Module_utilModule.js.html","title":"Source: src/Module/utilModule.js","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: src/Module/utilModule.js import coreLibrary from '../coreLibrary' /* we are not using the translationModule.getTranslation because the translations files are set in the widgets, we don't want to force the widgets to include static labels for outcomes. If we need more labels than \"draw\" we might want to consider doing some build-time magic to not include all the locales values */ const labelsTranslations = { draw: { cs_CZ: 'Remíza', da_DK: 'Uafgjort', de_AT: 'Unentschieden', de_CH: 'Unentschieden', de_DE: 'Unentschieden', el_GR: 'Ισοπαλία', en_AU: 'Draw', en_GB: 'Draw', es_ES: 'Empate', et_EE: 'Viik', fi_FI: 'Tasapeli', fr_BE: 'Nul', fr_CH: 'Nul', fr_FR: 'Nul', hu_HU: 'Döntetlen', it_IT: 'Pareggio', lt_LT: 'Lygiosios', lv_LV: 'Neizšķirts', nl_BE: 'Gelijkspel', nl_NL: 'Gelijkspel', no_NO: 'Uavgjort', pl_PL: 'Remis', pt_BR: 'Empate', pt_PT: 'Empate', ro_RO: 'Egalitate', ru_RU: 'Ничья', sv_SE: 'Oavgjort', tr_TR: 'Draw', }, } /** * Module with utility functions * @module utilModule */ export default { /** * Util method for return unique items between arrays * @param {Array} A First array * @param {Array} B Second array * @returns {Array} * @private */ diffArray(A, B) { var map = {}, C = [] for (var i = B.length; i--; ) { map[B[i]] = null } // any other value would do for (var i = A.length; i--; ) { if (!map.hasOwnProperty(A[i])) { C.push(A[i]) } } return C }, /** * Checks deep equality of two object. * @param {object} x First object * @param {object} y Second object * @returns {boolean} */ equals(x, y) { if (x === y) return true if (!(x instanceof Object) || !(y instanceof Object)) return false if (x.constructor !== y.constructor) return false /* eslint-disable no-continue */ for (var p in x) { if (!x.hasOwnProperty(p)) continue if (!y.hasOwnProperty(p)) return false if (x[p] === y[p]) continue if (typeof x[p] !== 'object') return false if (!this.equals(x[p], y[p])) return false } /* eslint-enable no-continue */ for (p in y) { if (y.hasOwnProperty(p) &amp;&amp; !x.hasOwnProperty(p)) return false } return true }, /** * Returns deep copy of given object. * @param {object} x Object to be cloned */ clone(x) { return JSON.parse(JSON.stringify(x)) }, /* Replaces expressions like \"{customer}\" from the provided string * to the value the have in the coreLibrary.config object * @param {String} str the string to replace the expressions in */ replaceConfigParameters(str) { if (str == null) { return str } const config = coreLibrary.config Object.keys(config).forEach(key =&gt; { var regex = new RegExp('{' + key + '}', 'g') var value = config[key] str = str.replace(regex, value) }) return str }, /** * Get decimal formatted odds. * @param {Number} odds Odds number * @returns {Number} */ getOddsDecimalValue(odds) { if (odds &lt; 100) { return odds.toFixed(2) } else if (odds &lt; 1000) { return odds.toFixed(1) } else { return odds.toFixed(0) } }, /** * Returns the outcome label translated. * @param {Object} outcome A betoffer outcome object * @param {Object} event Event object * @returns {string} */ getOutcomeLabel(outcome, event) { switch (outcome.type) { case 'OT_ONE': // Outcome has label 1. Applies to Threeway bet offers. return event.homeName case 'OT_CROSS': // Outcome has label X. Applies to Threeway bet offers. return labelsTranslations.draw[coreLibrary.config.locale] case 'OT_TWO': // Outcome has label 2. Applies to Threeway bet offers. return event.awayName case 'OT_OVER': // The “Over” outcome in Over/Under bet offer. return outcome.label + ' ' + outcome.line / 1000 case 'OT_UNDER': // The “Under” outcome in Over/Under bet offer. return outcome.label + ' ' + outcome.line / 1000 // Todo: Impelement these responses with translations // case 'OT_ODD': //The “Odd” outcome in Odd/Even bet offer. // break; // case 'OT_EVEN': //The “Even” outcome in Odd/Even bet offer. // break; // case 'OT_ONE_ONE': //1-1 outcome in Halftime/fulltime bet offer. // break; // case 'OT_ONE_TWO': //1-2 outcome in Halftime/fulltime bet offer. // break; // case 'OT_ONE_CROSS': //1-X outcome in Halftime/fulltime bet offer. // break; // case 'OT_TWO_ONE': //2-1 outcome in Halftime/fulltime bet offer. // break; // case 'OT_TWO_TWO': //2-2 outcome in Halftime/fulltime bet offer. // break; // case 'OT_TWO_CROSS': //2-X outcome in Halftime/fulltime bet offer. // break; // case 'OT_CROSS_ONE': //X-1 outcome in Halftime/fulltime bet offer. // break; // case 'OT_CROSS_TWO': //X-2 outcome in Halftime/fulltime bet offer. // break; // case 'OT_CROSS_CROSS': //X-X outcome in Halftime/fulltime bet offer. // break; // case 'OT_ONE_OR_TWO': //1 or 2 outcome in Double Chance bet offer. // break; // case 'OT_ONE_OR_CROSS': //1 or X outcome in Double Chance bet offer. // break; // case 'OT_CROSS_OR_TWO': //X or 2 outcome in Double Chance bet offer. // break; // case 'OT_YES': //“Yes” outcome in Head To Head and Yes/No bet offer. // break; // case 'OT_NO': //“No” outcome in Head To Head and Yes/No bet offer. // break; // case 'OT_OTHER': //“Other results” outcome in Result bet offer. // break; // case 'OT_UNTYPED': //Outcome does not have type. // break; // case 'OT_WC_HOME': //Outcome has label Home Win. Applies to WinCast bet offers. // break; // case 'OT_WC_DRAW': //Outcome has label Draw. Applies to WinCast bet offers. // break; // case 'OT_WC_AWAY': //Outcome has label Away Win. Applies to WinCast bet offers. // break; default: console.warn('Unhandled outcome type: ' + outcome.type, outcome) return outcome.label } }, } × Search results Close "},"src_Module_widgetModule.js.html":{"id":"src_Module_widgetModule.js.html","title":"Source: src/Module/widgetModule.js","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: src/Module/widgetModule.js /** * Module with methods to manipulate the widget and interact with the sportsbook * @module widgetModule */ import utilModule from './utilModule' import coreLibrary from '../coreLibrary' import eventsModule from './EventsModule' const EMBEDDED = process.env.EMBEDDED === 'true' export default { /** * Widget API object * @type {object} * @private */ get api() { return coreLibrary.widgetApi }, /** * Object in which you can add event listeners for Kambi Widget API events * * @deprecated use eventsModule * * Valid events listeners: * * 'WIDGET:HEIGHT': Widget height changed * * 'OUTCOME:REMOVED:{outcomeId}': Outcome with {outcomeId} removed * * 'OUTCOME:ADDED:{outcomeId}': Outcome with {outcomeId} added * * 'OUTCOME:UPDATE:{outcomeId}': Outcome with {outcomeId} updated * * 'WIDGET:ARGS': Widget args changed * * 'PAGE:INFO': Page info changed * * 'ODDS:FORMAT': Odds format changed * * 'CLIENT:CONFIG': Client config changed * * 'USER:LOGGED_IN': User logged in changed * * 'LIVE:EVENT:{eventId}': Live event statistics changed * * 'LIVE:EVENT:{eventId}:REMOVED': Not a live event anymore * * 'LIVE:EVENTDATA:{eventId}': Live event's statistics changed * * 'LIVE:EVENTDATA:{eventId}:REMOVED': Not a live event anymore * * 'LIVE:EVENTS': Live events list changed * * @example * * widgetModule.events * .subscribe('OUTCOME:ADDED:' + outcome.id, * ( data ) =&gt; { * ... * }); * */ events: eventsModule, /** * Stores all the betslip outcome ids we are watching * to trigger events * @type {array} * @private */ betslipIds: [], /** * Handles widget api response. * Emits events for each response * @param {Object} response * @private */ handleResponse(response) { switch (response.type) { case this.api.WIDGET_HEIGHT: // We've received a height response eventsModule.publish('WIDGET:HEIGHT', response.data) break case this.api.BETSLIP_OUTCOMES: // We've received a response with the outcomes currently in the betslip var i = 0, len = response.data.outcomes.length var updateIds = [] // Gather all the ids in the betslip in one array for (; i &lt; len; ++i) { updateIds.push(response.data.outcomes[i].id) } // Diff against what the coreLibrary already has stored so we know what was added and what was removed var removedIds = utilModule.diffArray(this.betslipIds, updateIds) var addedIds = utilModule.diffArray(updateIds, this.betslipIds) // Save the updated ids this.betslipIds = updateIds // Emit events for each removed id i = 0 len = removedIds.length for (; i &lt; len; ++i) { eventsModule.publish('OUTCOME:REMOVED:' + removedIds[i]) } // Emit events for each added id i = 0 len = addedIds.length for (; i &lt; len; ++i) { eventsModule.publish('OUTCOME:ADDED:' + addedIds[i]) } // Emit a generic update in case we want to use that eventsModule.publish('OUTCOMES:UPDATE', response.data) break case this.api.WIDGET_ARGS: // We've received a response with the arguments set in the coreLibrary.args = response.data eventsModule.publish('WIDGET:ARGS', response.data) break case this.api.PAGE_INFO: // Received page info response coreLibrary.setPageInfo(response.data) eventsModule.publish('PAGE:INFO', response.data) break case this.api.CLIENT_ODDS_FORMAT: // Received odds format response coreLibrary.oddsFormat = response.data eventsModule.publish('ODDS:FORMAT', response.data) break case this.api.CLIENT_CONFIG: coreLibrary.config = response.data eventsModule.publish('CLIENT:CONFIG', response.data) break case this.api.USER_LOGGED_IN: console.debug('User logged in', response.data) eventsModule.publish('USER:LOGGED_IN', response.data) break case 'Setup': eventsModule.publish('Setup response', response.data) break } }, /** * Creates url from given path and optionalRoot * @param {String} path * @param {String} optionalRoot * @returns {String} */ createUrl(path, optionalRoot) { return this.api.createUrl(path, optionalRoot) }, /** * Creates a filter url from given array * @example * destination = ['/football/europa_league/', '/football/world_cup_qualifying_-_europe/']; * @param {Array} destination * @returns {string} */ createFilterUrl(terms) { // wapi.createFilterUrl is very buggy, so we made our own implementation of it // return this.api.createFilterUrl(destination, coreLibrary.config.routeRoot); const urlBase = coreLibrary.config.routeRoot const segments = terms .filter(term =&gt; term.indexOf('/') === 0) .sort() .reduce((segments, term) =&gt; { const coords = [] term .replace(/\\/+$/, '') .split('/') .slice(1) .forEach((termKey, i) =&gt; { if (!(i in segments)) { segments[i] = [] } let pointer = segments[i] if (i &gt; 0) { coords.forEach(coord =&gt; { for (let j = 0; j &lt;= coord; j++) { if (pointer[j] == null) { pointer.push(j === coord ? [] : 'all') } } pointer = pointer[coord] }) } if (pointer.indexOf(termKey) === -1) { pointer.push(termKey) } coords[i] = pointer.length - 1 }) return segments }, []) let route = '#' + urlBase.replace(/.*?#/, '').replace(/^\\//, '') route += segments .reduce( (str, segment) =&gt; str + '/' + JSON.stringify(segment).slice(1, -1), '' ) .replace(/\"/g, '') .replace(/(,all)+(\\/|]|$)/g, '$2') for (let i = 0; i &lt;= segments.length; i++) { route = route.replace(/\\[([^,\\]]*)]/g, '$1') } const attributes = terms.filter(term =&gt; term.indexOf('/') !== 0).join(',') if (attributes) { for (let j = 0; j &lt; 4 - segments.length; j++) { route += '/all' } route += '/' + attributes } return route.match(/filter$/) ? route + '/all' : route }, /** * Returns the page type page type * @returns {String} */ getPageType() { if (!coreLibrary.pageInfo.pageType) { return '' } var pageType = coreLibrary.pageInfo.pageType switch (pageType) { case 'event': return '' case 'event-live': return 'live/' default: console.info('Unknown page type: ' + pageType) break } }, /** * Makes widget api request for setupdata * @param {fn} callback Callback */ requestSetup(callback) { this.api.requestSetup(callback) }, /** * Requests widget height from widget api */ requestWidgetHeight() { this.api.request(this.api.WIDGET_HEIGHT) }, /** * Set widget iframe height * @param {Number} height the height in pixels */ setWidgetHeight(height) { if (EMBEDDED) { coreLibrary.embeddedElement.style.height = height + 'px' coreLibrary.args.onHeightChange(height) return } this.api.set(this.api.WIDGET_HEIGHT, height) }, /** * tries to adapt the widget iframe height to match the content * * Only works if the html and body tags don't have height: 100% styling rule */ adaptWidgetHeight() { if (EMBEDDED) { const core = coreLibrary const newHeight = window.getComputedStyle(coreLibrary.rootElement).height coreLibrary.embeddedElement.style.height = newHeight coreLibrary.args.onHeightChange(newHeight) return } // tries to adapt the widget iframe height to match the content var body = document.body, html = document.documentElement var heights = [body.offsetHeight, html.offsetHeight] // scrollHeight is the property used to get the size of the content of the page when it is bigger than the viewport // on IE&lt;=11, Edge and firefox html.scrollHeight has the value of the viewport if the content is smaller than the viewport. On Chrome and others it is the other way around // Need to check specifically for Edge as coreLibrary.browser on Edge returns Chrome if (window.navigator.userAgent.indexOf('Edge') &gt; -1) { heights.push(html.scrollHeight) } else if ( coreLibrary.browser === 'firefox' || coreLibrary.browser === 'chrome' || (coreLibrary.browser === 'internet-explorer' &amp;&amp; parseInt(coreLibrary.browserVersion, 10) &lt;= 11) || coreLibrary.browser === 'ios' ) { heights.push(body.scrollHeight) } else { heights.push(html.scrollHeight) } var height = Math.max.apply(null, heights) this.api.set(this.api.WIDGET_HEIGHT, height) }, /** * Enables/disables animations of changing the height of the iframe * @param {boolean} enableTransition new state to be */ enableWidgetTransition(enableTransition) { if (enableTransition) { this.api.set(this.api.WIDGET_ENABLE_TRANSITION) } else { this.api.set(this.api.WIDGET_DISABLE_TRANSITION) } }, /** * Call api to remove widget from the sportsbook */ removeWidget(err) { coreLibrary.args.onWidgetRemoved(err) if (EMBEDDED) { const rootElement = coreLibrary.rootElement while (rootElement.firstChild) { rootElement.removeChild(rootElement.firstChild) } coreLibrary.embeddedElement.style.display = 'none' return } this.api.remove() }, /** * Method to navigate to a live event page * @param {number} eventId */ navigateToLiveEvent(eventId) { this.navigateClient('event/live/' + eventId) }, /** * Method to navigate to a pre-live event page * @param {number} eventId */ navigateToEvent(eventId) { this.navigateClient('event/' + eventId) }, /** * Method to navigate to a filter page * @param {String} filterParams */ navigateToFilter(filterParams) { if ( typeof filterParams === 'string' &amp;&amp; filterParams.indexOf('filter/') === -1 ) { filterParams = 'filter/' + filterParams } this.navigateClient(filterParams) }, /** * Navigates to the live events page */ navigateToLiveEvents() { this.navigateClient(['in-play']) }, /** * Adds an outcomes to the betslip * @param {Array&lt;Number&gt;|Number} outcomes ids of the outcomes to add * @param {Array&lt;Number&gt;|Number} stakes the value of the stakes to add (referencing the ids in the outcomes parameter) * @param {String} updateMode defaults to 'append', but also accepts 'replace' * @param {String} source */ addOutcomeToBetslip(outcomes, stakes, updateMode, source) { var arrOutcomes = [] // Check if the outcomes parameter is an array and add it, otherwise add the the single value as an array if (Array.isArray(outcomes)) { arrOutcomes = outcomes } else { arrOutcomes.push(outcomes) } // Setup the data object to be sent to the widget API var data = { outcomes: arrOutcomes, } // Check if we got any stakes passed to use, add them to the data object if so if (stakes != null) { if (Array.isArray(stakes)) { data.stakes = stakes } else { data.stakes = [stakes] } } // Set the coupon type, defaults to TYPE_SINGLE data.couponType = arrOutcomes.length === 1 ? this.api.BETSLIP_OUTCOMES_ARGS.TYPE_SINGLE : this.api.BETSLIP_OUTCOMES_ARGS.TYPE_COMBINATION // Set the update mode, defaults to UPDATE_APPEND data.updateMode = updateMode !== 'replace' ? this.api.BETSLIP_OUTCOMES_ARGS.UPDATE_APPEND : this.api.BETSLIP_OUTCOMES_ARGS.UPDATE_REPLACE if (source != null) { data.source = source } // Add tracking name if it's set if (coreLibrary.widgetTrackingName != null) { data.name = coreLibrary.widgetTrackingName } // Send the data to the widget this.api this.api.set(this.api.BETSLIP_OUTCOMES, data) }, /** * Removes outcomes from betslip * @param {Array&lt;Number&gt;|Number} outcomes ids of the outcomes to remove form the betslip */ removeOutcomeFromBetslip(outcomes) { var arrOutcomes = [] if (Array.isArray(outcomes)) { arrOutcomes = outcomes } else { arrOutcomes.push(outcomes) } var data = { outcomes: arrOutcomes } // Add tracking name if it's set if (coreLibrary.widgetTrackingName != null) { data.name = coreLibrary.widgetTrackingName } this.api.set(this.api.BETSLIP_OUTCOMES_REMOVE, data) }, /** * Requests betslip outcomes */ requestBetslipOutcomes() { this.api.request(this.api.BETSLIP_OUTCOMES) }, /** * Requests page info */ requestPageInfo() { this.api.request(this.api.PAGE_INFO) }, /** * Requests widget args */ requestWidgetArgs() { this.api.request(this.api.WIDGET_ARGS) }, /** * Requests client config */ requestClientConfig() { this.api.request(this.api.CLIENT_CONFIG) }, /** * Requests odds format */ requestOddsFormat() { this.api.request(this.api.CLIENT_ODDS_FORMAT) }, /** * Requests american odds * @param {Number} odds * @returns {Promise} */ requestOddsAsAmerican(odds) { return new Promise(resolve =&gt; { this.api.requestOddsAsAmerican(odds, americanOdds =&gt; { resolve(americanOdds) }) }) }, /** * Requests fractional odds * @param {Number} odds * @returns {Promise} */ requestOddsAsFractional(odds) { return new Promise(resolve =&gt; { this.api.requestOddsAsFractional(odds, fractionalOdds =&gt; { resolve(fractionalOdds) }) }) }, /** * Navigates to a page in the sportsbook * @param {String|Array} destination fragment part of the URL to navigate to (the part after the # in the URL) */ navigateClient(destination) { var finalTarget = '' if (typeof destination === 'string') { finalTarget = '#' + coreLibrary.config.routeRoot + destination } else if (Array.isArray(destination)) { finalTarget = this.api.createFilterUrl( destination, coreLibrary.config.routeRoot ) } if (EMBEDDED) { coreLibrary.args.onWidgetNavigateClient( finalTarget, coreLibrary.widgetTrackingName != null ? coreLibrary.widgetTrackingName : null ) } else { if (coreLibrary.widgetTrackingName != null) { this.api.navigateClient(finalTarget, coreLibrary.widgetTrackingName) } else { this.api.navigateClient(finalTarget) } } }, } × Search results Close "},"src_Module_EventsModule_schedule.js.html":{"id":"src_Module_EventsModule_schedule.js.html","title":"Source: src/Module/EventsModule/schedule.js","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: src/Module/EventsModule/schedule.js import utilModule from '../utilModule' /* * Utility for running tasks periodically with equality check. * @memberof module:eventsModule */ const Schedule = { /* * Currently running tasks map * @type {object.&lt;string, {interval: number, lastResult: object|null}&gt;} */ tasks: {}, /* * Runs given task function periodically. * @param {string} key Unique task key * @param {function():Promise} taskFunc Task function * @param {function(mixed)} resultHandler Called with task result * @param {number} interval Task interval (in milliseconds) * @param {boolean} checkEquality Compare current and last result, don't call resultHandler if both are equal */ periodically(key, taskFunc, resultHandler, { interval, checkEquality }) { if (this.tasks.hasOwnProperty(key)) { return } this.tasks[key] = { /** * Task runner interval */ interval: setInterval(() =&gt; { const task = this.tasks[key] taskFunc() .then(result =&gt; { if ( !(checkEquality &amp;&amp; utilModule.equals(task.lastResult, result)) ) { resultHandler(result) } if (checkEquality) { // result needs to be cloned as it could be modified in further processing task.lastResult = utilModule.clone(result) } }) .catch(error =&gt; console.error(error)) }, interval), /** * Last result pointer for equality check */ lastResult: null, } }, /* * Stops given task. * @param {string} key Task key */ stop(key) { if (!this.tasks.hasOwnProperty(key)) { return } clearInterval(this.tasks[key].interval) delete this.tasks[key] }, } export default Schedule × Search results Close "},"node_modules_kamb-wc-widget-components_src_List_ScrolledList_ScrolledList.jsx.html":{"id":"node_modules_kamb-wc-widget-components_src_List_ScrolledList_ScrolledList.jsx.html","title":"Source: node_modules/kamb-wc-widget-components/src/List/ScrolledList/ScrolledList.jsx","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: node_modules/kamb-wc-widget-components/src/List/ScrolledList/ScrolledList.jsx /* eslint-disable camelcase */ import React, { Children, Component } from 'react' import PropTypes from 'prop-types' import styles from './ScrolledList.scss' import ArrowButton from './ArrowButton' import ItemContainer from '../ItemContainer' /* * Window resize handling reflex (in milliseconds) * @type {number} */ const UPDATE_MOMENTUM = 150 /* * Duration of bar element scrollLeft animation (in milliseconds) * @type {number} */ const BAR_TRANSITION_DURATION = 300 /** * Items alignment constants * @enum {string} * @readonly * @example * &lt;ScrolledList alignItems={ScrolledList.ALIGN_ITEMS.SPACE_BETWEEN}&gt;...&lt;/ScrolledList&gt; */ const ScrolledList_ALIGN_ITEMS = { /** * List items will be aligned to the left. * @member {string} */ LEFT: 'flex-start', /** * List items will be aligned to the right. * @member {string} */ RIGHT: 'flex-end', /** * List items will be centered. * @member {string} */ CENTER: 'center', /** * There will be space around all items. * @member {string} */ SPACE_AROUND: 'space-around', /** * There will be space only between items. * @member {string} */ SPACE_BETWEEN: 'space-between', } /** * Scroll to selected item modes * @enum {string} * @readonly * @example * &lt;ScrolledList scrollToItemMode={ScrolledList.SCROLL_TO_ITEM_MODE.TO_LEFT}&gt;...&lt;/ScrolledList&gt; */ const ScrolledList_SCROLL_TO_ITEM_MODE = { /** * Selected item will be the first object on the left side of eye shot */ TO_LEFT: 'to-left', /** * Selected item will be at the center of eye shot */ CENTER: 'center', } /* * Determines if component is running on touch screen device. * @returns {boolean} */ const isTouchScreen = () =&gt; 'ontouchstart' in window /* * Performs animation on given element's property. * @param {HTMLElement} element Element to animate * @param {string} property Element's property to animate * @param {number} value Target property value * @param {number} duration Animation duration */ const animate = function(element, property, value, duration) { let requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || (callback =&gt; { const now = Date.now() // further calls will be invoked with future timestamp requestAnimationFrame = callback =&gt; callback(now + duration) // first call will run step function immediately callback(now) }) let start = null const initial = element[property], delta = value - initial return new Promise(resolve =&gt; { const step = function(timestamp) { if (!start) { start = timestamp } let progress = (timestamp - start) / duration if (progress &gt; 1) { progress = 1 } // easeOutQuad element[property] = -delta * progress * (progress - 2) + initial // animation finished if (progress &gt;= 1) { resolve() return } requestAnimationFrame(step) } requestAnimationFrame(step) }) } /** * Horizontal scrolled list component. * If items won't fit the container the list will be scrolled. Otherwise if items take less space * than the container they will be aligned according to [alignItems]{@link widget-components.ScrolledList.propTypes} property. * @memberOf widget-components */ class ScrolledList extends Component { /* * Constructs. * @param {object} props Component properties */ constructor(props) { super(props) this.state = { item: props.selected, } this.itemWidths = [] this.prevPage = this.prevPage.bind(this) this.nextPage = this.nextPage.bind(this) this.enqueueUpdate = this.enqueueUpdate.bind(this) } /* * Called after component rendering to DOM. */ componentDidMount() { window.addEventListener('resize', this.enqueueUpdate) this.scrollToItem(this.state.item) this.updateItemsAlignment() } /* * Called on external props change. */ componentDidUpdate(prevProps) { if (prevProps.selected !== this.props.selected) { this.scrollToItem(this.props.selected) } } /* * Called before removing component. */ componentWillUnmount() { window.removeEventListener('resize', this.enqueueUpdate) } /* * Selects item with given index. * @param {number} idx Item index */ onItemClick(idx) { if (this.props.onItemClick) { this.props.onItemClick(idx) } this.setState({ item: idx }) } /* * Updates internal state with item's width and re-renders view if necessary. * @param {number} idx Item index * @param {number?} width Desired item width */ setItemWidth(idx, width) { if (typeof width !== 'number') { return } if (this.itemWidths[idx] !== width) { this.itemWidths[idx] = width this.enqueueUpdate() } } /* * Throttles widget rendering updates. */ enqueueUpdate() { if (this.updateTimeout) { clearTimeout(this.updateTimeout) } this.updateTimeout = setTimeout(() =&gt; { this.updateItemsAlignment() this.scrollToItem(this.state.item) this.forceUpdate() }, UPDATE_MOMENTUM) } /* * Current scroll left offset (in pixels). */ get currentScrollLeft() { return this.eyeshot ? this.eyeshot.scrollLeft : 0 } /* * Field of view width. * @returns {number|null} */ get eyeshotWidth() { return this.eyeshot ? this.eyeshot.offsetWidth : null } /* * Returns maximal scroll left offset. * @returns {number|null} */ get maxScrollLeft() { if (!this.eyeshotWidth) { return null } return ( this.computeItemsWidth(0, Children.count(this.props.children) - 1) - this.eyeshotWidth ) } /* * Updates items alignment if they take less space than container width. */ updateItemsAlignment() { if (!this.bar) { return } const itemsWidth = this.computeItemsWidth( 0, Children.count(this.props.children) - 1 ) if (itemsWidth &lt; this.eyeshotWidth) { this.bar.style.justifyContent = this.props.alignItems } else { this.bar.style.justifyContent = '' } } /* * Scrolls list to given offset. * @param {number} offset Scroll offset */ scrollTo(offset) { if (!(this.maxScrollLeft &amp;&amp; this.eyeshot)) { return } offset = Math.round(offset) let scrollLeft = offset &gt; this.maxScrollLeft ? this.maxScrollLeft : offset scrollLeft = scrollLeft &lt; 0 ? 0 : scrollLeft if (scrollLeft == this.currentScrollLeft) { return } animate( this.eyeshot, 'scrollLeft', scrollLeft, BAR_TRANSITION_DURATION ).then(() =&gt; this.forceUpdate()) } /* * Scrolls bar to given item. * @param {number} item Item index * * Example for item=2 * * computeItemsWidth(0, item - 1) * &lt;---------------------------&gt; * * computeItemsWidth(item) * &lt;-----------------&gt; * * /=========================\\ * /-----------------------#-------------------------#-------------------------------\\ * | | # | | # | | * | 0 | 1 # | 2 | # 3 | 4 | * | | # | | # | | * \\-----------------------#-------------------------#-------------------------------/ * \\=========================/ * * &lt;------ eyeshotWidth -----&gt; */ scrollToItem(item) { switch (this.props.scrollToItemMode) { case ScrolledList_SCROLL_TO_ITEM_MODE.TO_LEFT: this.scrollTo(item ? this.computeItemsWidth(0, item - 1) : 0) break case ScrolledList_SCROLL_TO_ITEM_MODE.CENTER: default: this.scrollTo( (item ? this.computeItemsWidth(0, item - 1) : 0) - (this.eyeshotWidth - this.computeItemsWidth(item)) / 2 ) } } /* * Should prev button be shown * @returns {boolean} */ get showPrevButton() { return this.currentScrollLeft &gt; 0 } /* * Should next button be shown * @returns {boolean} */ get showNextButton() { return this.currentScrollLeft &lt; this.maxScrollLeft } /* * Returns item widths sum for given range. * @param {number} start First item index * @param {number} end Last item index * @returns {number} */ computeItemsWidth(start, end = start) { return this.itemWidths .slice(start, end + 1) .reduce((sum, itemWidth) =&gt; sum + (itemWidth ? itemWidth : 0), 0) } /* * Computes average item width across all items. * @returns {number} */ get averageItemWidth() { return ( this.computeItemsWidth(0, Children.count(this.props.children) - 1) / Children.count(this.props.children) ) } /* * Scrolls list to previous page. */ prevPage() { this.scrollTo( this.currentScrollLeft - this.props.step * this.averageItemWidth ) } /* * Scrolls list to next page. */ nextPage() { this.scrollTo( this.currentScrollLeft + this.props.step * this.averageItemWidth ) } /* * Renders scrolled item list. * @returns {XML} */ render() { const className = [ styles.container, this.props.showControls ? '' : styles['no-controls'], isTouchScreen() ? styles.touch : '', ] .join(' ') .trim() let scrolledListHasHorizontalSpaceLeft = false const itemsWidth = this.computeItemsWidth( 0, Children.count(this.props.children) - 1 ) if (itemsWidth &lt; this.eyeshotWidth) { scrolledListHasHorizontalSpaceLeft = true } return ( &lt;div className={className} style={{ opacity: itemsWidth === 0 ? 0 : 1 }} ref={el =&gt; (this.container = el)} &gt; &lt;div className={styles.eyeshot} ref={el =&gt; (this.eyeshot = el)}&gt; &lt;div className={styles.bar} ref={el =&gt; (this.bar = el)}&gt; {Children.map(this.props.children, (child, i) =&gt; { if (scrolledListHasHorizontalSpaceLeft) { child = React.cloneElement(child, { scrolledListHasHorizontalSpaceLeft, }) } return this.props.renderItemContainer({ key: i, selected: this.state.item == i, onClick: this.onItemClick.bind(this, i), onWidth: this.setItemWidth.bind(this, i), children: child, }) })} &lt;/div&gt; &lt;/div&gt; {this.props.showControls &amp;&amp; this.props.renderPrevButton({ onClick: this.prevPage, disabled: !this.showPrevButton, backgroundColor: this.props.arrowButtonBackground, })} {this.props.showControls &amp;&amp; this.props.renderNextButton({ onClick: this.nextPage, disabled: !this.showNextButton, backgroundColor: this.props.arrowButtonBackground ? this.props.arrowButtonBackground : null, })} &lt;/div&gt; ) } } ScrolledList.ALIGN_ITEMS = ScrolledList_ALIGN_ITEMS ScrolledList.SCROLL_TO_ITEM_MODE = ScrolledList_SCROLL_TO_ITEM_MODE /** * Should return rendered prev/next scroll button. * @callback ScrolledList_RenderButton * @param {ScrolledList_RenderButtonArgs} args Contains properties which will control the button * @returns ReactElement * * @example &lt;caption&gt;Using custom button for next/prev.&lt;/caption&gt; * ({onClick, disabled}) =&gt; &lt;CustomButton onClick={onClick} disabled={disabled} /&gt; * * @example &lt;caption&gt;Shorthand syntax can be used once function arguments and component properties names match.&lt;/caption&gt; * args =&gt; &lt;CustomButton {...args} /&gt; */ /** * @name ScrolledList_RenderButtonArgs * @property {function} onClick Click handler * @property {boolean} disabled Controls whether button should be rendered as disabled or not */ /** * Should return rendered item container. * Container is responsible for receiving clicks, properly rendering selected state and optionally hover. * @callback ScrolledList_RenderItemContainer * @param {ScrolledList_RenderItemContainerArgs} args Container properties which will control the container * @returns ReactElement * * @example &lt;caption&gt;Using custom item container&lt;/caption&gt; * ({selected, onClick, onWidth, children}) =&gt; * &lt;CustomItemContainer * selected={selected} * onClick={onClick} * onWidth={onWidth}&gt; * {children} * &lt;/CustomItemContainer&gt; * * @example &lt;caption&gt;Shorthand syntax can be used once function arguments and component properties names match.&lt;/caption&gt; * args =&gt; &lt;CustomItemContainer {...args}&gt;{args.children}&lt;/CustomItemContainer&gt; */ /** * @name ScrolledList_RenderItemContainerArgs * @property {boolean} selected Controls whether item should be rendered as currently selected or normally * @property {function} onClick Called once item has been clicked * @property {function} onWidth Called when item width is determined or has been changed * @property {ReactElement} children Item contents */ /** * @property [children] {ReactElement[]} Items list * @property [onItemClick] {function(number)} Item click handler. Called with item index argument. * @property [selected=0] {number} Initially selected item index * @property [step=2] {number} Scroll step (items count) * @property [alignItems=CENTER] {ScrolledList_ALIGN_ITEMS} Method of aligning items when they take less width than the container has * @property [renderPrevButton] {ScrolledList_RenderButton} Function capable of rendering button responsible for scrolling left. Renders left arrow button by default. * @property [renderNextButton] {ScrolledList_RenderButton} Function capable of rendering button responsible for scrolling right. Renders right arrow button by default. * @property [renderItemContainer] {ScrolledList_RenderItemContainer} Function capable of rendering item container. Renders Kambi-styled item container by default. * @property [scrollToItemMode=CENTER] {ScrolledList_SCROLL_TO_ITEM_MODE} Scroll to selected item mode * @property [showControls] {boolean} Decides whether next/prev controls be visible e.g. can be hidden in mobile mode */ ScrolledList.propTypes = { children: PropTypes.node, onItemClick: PropTypes.func, selected: PropTypes.number, step: PropTypes.number, alignItems: PropTypes.oneOf( Object.keys(ScrolledList_ALIGN_ITEMS).map(k =&gt; ScrolledList_ALIGN_ITEMS[k]) ), renderPrevButton: PropTypes.func, renderNextButton: PropTypes.func, renderItemContainer: PropTypes.func, scrollToItemMode: PropTypes.oneOf( Object.keys(ScrolledList_SCROLL_TO_ITEM_MODE).map( k =&gt; ScrolledList_SCROLL_TO_ITEM_MODE[k] ) ), showControls: PropTypes.bool, arrowButtonBackground: PropTypes.string, } ScrolledList.defaultProps = { selected: 0, step: 2, alignItems: ScrolledList_ALIGN_ITEMS.CENTER, scrollToItemMode: ScrolledList_SCROLL_TO_ITEM_MODE.CENTER, renderPrevButton: props =&gt; &lt;ArrowButton type=\"left\" {...props} /&gt;, renderNextButton: props =&gt; &lt;ArrowButton type=\"right\" {...props} /&gt;, renderItemContainer: args =&gt; ( &lt;ItemContainer {...args}&gt;{args.children}&lt;/ItemContainer&gt; ), showControls: true, } export default ScrolledList × Search results Close "},"node_modules_kamb-wc-widget-components_src_TabPagination_TabPagination.jsx.html":{"id":"node_modules_kamb-wc-widget-components_src_TabPagination_TabPagination.jsx.html","title":"Source: node_modules/kamb-wc-widget-components/src/TabPagination/TabPagination.jsx","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: node_modules/kamb-wc-widget-components/src/TabPagination/TabPagination.jsx import React, { Children, Component } from 'react'; import PropTypes from 'prop-types'; import ScrolledList from '../List/ScrolledList/ScrolledList'; /** * Tab Pagination component. * Component should receive list of tab contents as children. * It will render upper tab bar (for switching tabs). * Once a tab is clicked a tab content will be switched. * @memberOf widget-components */ class TabPagination extends Component { /* * Constructs. * @param {object} props Component properties */ constructor(props) { super(props); this.state = { selected: this.props.selected }; this.switchTab = this.switchTab.bind(this); } /* * Switches to given tab * @param {number} idx Tab index */ switchTab(idx) { this.setState({ selected: idx }); // switching the tab is done in the next tick setTimeout(() =&gt; this.props.onTabChange &amp;&amp; this.props.onTabChange(idx), 0); } /* * Creates TabPagination markup * @returns {XML} */ render() { const children = Children.toArray(this.props.children); return ( &lt;div&gt; {this.props.renderTabList({ selected: this.state.selected, onItemClick: this.switchTab, children: children.map((a, i) =&gt; this.props.renderTab(i)) })} &lt;div&gt; {children[this.state.selected]} &lt;/div&gt; &lt;/div&gt; ); } } /** * Renders tab for given index. The tab will be placed inside upper tab bar. * @callback TabPagination_RenderTab * @param {number} idx Tab index * @returns ReactElement * @example * idx =&gt; &lt;div style={{width: 50, height: 50}}&gt;Tab &lt;strong&gt;#{idx}&lt;/strong&gt;&lt;/div&gt; */ /** * Renders upper tab list. * @callback TabPagination_RenderTabList * @param {TabPagination_RenderTabListArgs} args Contains properties which will control tab bar behaviour * @returns ReactElement * * @example &lt;caption&gt;Using custom tab bar component&lt;/caption&gt; * ({selected, onItemClick, children}) =&gt; * &lt;CustomTabBar * selected={selected} * onItemClick={onItemClick}&gt; * {children} * &lt;/CustomTabBar&gt; * * @example &lt;caption&gt;Shorthand syntax can be used once function arguments and component properties names match.&lt;/caption&gt; * args =&gt; &lt;CustomTabBar {...args}&gt;{args.children}&lt;/CustomTabBar&gt; * * @example &lt;caption&gt;Usage of build-in {@link widget-components.FixedList|FixedList} component as tab bar.&lt;/caption&gt; * args =&gt; &lt;FixedList {...args}&gt;{args.children}&lt;/FixedList&gt; * * @example &lt;caption&gt;Advanced usage of {@link widget-components.ScrolledList|ScrolledList} component as tab bar.&lt;/caption&gt; * args =&gt; * &lt;ScrolledList * {...args} * alignItems={ScrolledList.ALIGN_ITEMS.LEFT} * step={3}&gt; * {args.children} * &lt;/ScrolledList&gt; */ /** * @name TabPagination_RenderTabListArgs * @property {number} selected Initially selected list item (tab) * @property {function(number)} onItemClick Item clicked handler. Called with item's index argument. * @property {ReactElement[]} children Array of list items (tabs) */ /** * Called after switching tabs. * @callback TabPagination_OnTabChange * @param {number} idx Tab index * @example * idx =&gt; console.log('currently selected tab: ' + idx) */ /** * @property [children] {ReactElement[]} Tab content elements * @property [renderTab] {TabPagination_RenderTab} Function called in order to render single tab on tab bar. Renders tab index by default. * @property [renderTabList] {TabPagination_RenderTabList} Function called in order to render tab bar. Renders {@link widget-components.ScrolledList|ScrolledList} by default. * @property [selected=0] {number} Currently selected tab index * @property [onTabChange] {TabPagination_OnTabChange} Function called after switching tabs */ TabPagination.propTypes = { children: PropTypes.node, renderTab: PropTypes.func, renderTabList: PropTypes.func, selected: PropTypes.number, onTabChange: PropTypes.func }; TabPagination.defaultProps = { renderTab: idx =&gt; &lt;div key={idx} style={{ padding: 16 }}&gt;&lt;strong&gt;{idx}&lt;/strong&gt;&lt;/div&gt;, renderTabList: args =&gt; &lt;ScrolledList {...args}&gt;{args.children}&lt;/ScrolledList&gt;, selected: 0 }; export default TabPagination; × Search results Close "},"node_modules_kamb-wc-widget-components_src_components.js.html":{"id":"node_modules_kamb-wc-widget-components_src_components.js.html","title":"Source: node_modules/kamb-wc-widget-components/src/components.js","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: node_modules/kamb-wc-widget-components/src/components.js /** * Reusable React Components * It is not necessary to make the whole widget in React in order to use these components, they can be mixed with non React code as necessary. * @example // this example shows how to use the Header component without using JSX import React from 'react'; import ReactDOM from 'react-dom'; import { Header } 'kamb-wc-widget-components'; // Basic React API: React.createElement(Component, props, children) // check widget-components.Header documentation for all the options const header = React.createElement( Header, { collapsable: false }, 'This is the Header title' ) // ReactDOM API: ReactDOM.render(reactElement, HTMLElement) // places the Header in the page: ReactDOM.render(header, document.getElementById('header')) * @example // this example shows how to use the Header component using JSX // note that JSX only works in .jsx files import React from 'react'; import ReactDOM from 'react-dom'; import { Header } 'kamb-wc-widget-components'; ReactDOM.render( &lt;Header collapsable={false}&gt; This is the Header title &lt;/Header&gt; , document.getElementById('header')) * @namespace widget-components */ export { default as OutcomeButton } from './OutcomeButton/OutcomeButton'; export { default as OutcomeButtonUI } from './OutcomeButton/OutcomeButtonUI'; export { default as TabPagination } from './TabPagination/TabPagination'; export { default as FixedList } from './List/FixedList/FixedList'; export { default as ScrolledList } from './List/ScrolledList/ScrolledList'; export { default as DropdownButton } from './DropdownButton/DropdownButton'; export { default as Header } from './Header/Header'; export { default as ActionButton } from './ActionButton/ActionButton'; export { default as IconHeader } from './IconHeader/IconHeader'; export { default as Carousel } from './Carousel/Carousel'; export { default as BlendedBackground } from './BlendedBackground/BlendedBackground'; × Search results Close "},"node_modules_kamb-wc-widget-components_src_DropdownButton_DropdownButton.jsx.html":{"id":"node_modules_kamb-wc-widget-components_src_DropdownButton_DropdownButton.jsx.html","title":"Source: node_modules/kamb-wc-widget-components/src/DropdownButton/DropdownButton.jsx","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: node_modules/kamb-wc-widget-components/src/DropdownButton/DropdownButton.jsx import React, { Component } from 'react'; import PropTypes from 'prop-types'; import styles from './DropdownButton.scss'; /** * Component for creating a button that when clicked shows a menu based in the provided options. * @memberof widget-components */ class DropdownButton extends Component { constructor(props) { super(props); this.state = { selected: this.props.selected, dropDown: false }; this.buttonElement = null; this.onBackgroundClick = this.onBackgroundClick.bind(this); this.onButtonClick = this.onButtonClick.bind(this); } /* * called on background click when drop down window is open * @param {SyntheticEvent} event Click event */ onBackgroundClick(ev) { // setState prevents event from being processed by onOptionClick handler // so it is moved to the next cycle this.setState({ dropDown: false }); window.document.documentElement.removeEventListener('click', this.onBackgroundClick, true); let btnIndex = ev.target.getAttribute('data-kw-dropdown-button-index'); if (btnIndex == null) { return; } btnIndex = parseInt(btnIndex, 10); if (this.state.selected === btnIndex) { return; } this.setState({ selected: btnIndex }); this.props.onChange(btnIndex); } /* * Shows drop down box with available options. * @param {SyntheticEvent} event Click event */ onButtonClick(event) { event.stopPropagation(); this.setState({ dropDown: true, }); window.document.documentElement.addEventListener('click', this.onBackgroundClick, true); // add event to the capture phase instead of bubble phase } /* * Renders button * @returns {XML} */ render() { // calculating position of dropdown while in mobile mode let dropdownMobileStyling = {}; if (this.state.dropDown &amp;&amp; this.buttonElement) { const { top, bottom } = this.buttonElement.getBoundingClientRect(); dropdownMobileStyling = { top: top, bottom: 'auto' }; if (this.props.verticalAlignment === 'bottom') { dropdownMobileStyling = { top: 'auto', bottom: Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - bottom }; } } let cssHAlignClass = styles.leftAlign; if (this.props.horizontalAlignment === 'right') { cssHAlignClass = styles.rightAlign; } let cssVAlignClass = styles.topAlign; if (this.props.verticalAlignment === 'bottom') { cssVAlignClass = styles.bottomAlign; } return ( &lt;div className={styles.general}&gt; &lt;button ref={(node) =&gt; { this.buttonElement = node }} className={'KambiWidget-card-support-text-color ' + styles.button} onClick={this.onButtonClick} &gt; {this.props.options[this.state.selected]} &lt;i /&gt; &lt;/button&gt; { this.state.dropDown &amp;&amp; &lt;ul style={dropdownMobileStyling} className={`${styles.dropDown} ${cssHAlignClass} ${cssVAlignClass}`} &gt; {this.props.options.map((option, i) =&gt; { const classNames = [ 'KambiWidget-card-background-color', 'KambiWidget-card-background-color--hoverable', 'KambiWidget-card-background-color--clickable' ]; if (this.state.selected === i) { classNames.push('KambiWidget-primary-color'); } else { classNames.push('KambiWidget-card-text-color'); } return ( &lt;li key={option} data-kw-dropdown-button-index={i} className={classNames.join(' ')} &gt; {option} &lt;/li&gt; ); })} &lt;/ul&gt; } &lt;/div&gt; ); } } /** * @property options {Array.&lt;string&gt;} Required. Options to show when the user clicks the button, translations are not applied * @property onChange {Function(index)} Required. Function to be invoked when the user clicks an option, receives the index of the option as an argument. If the user clicks the currently selected option this function is not invoked * @property [selected=0] {number} Defines which option should be checked upon component creation * @property [horizontalAlignment='right'] {'left'|'right'} Horizontal alignment of the dropdown box. If 'left' will match the left corner of the dropdown with the left corner of the button, if 'right' will match the right corner for the dropdown to the right corner of the button. If widget width is smaller than 925 the dropdown will ignore this option and will cover the full width of the widget * @property [verticalAlignment='top'] {'top'|'bottom'} Vertical alignment of the dropdown box. If 'top' will match the top corner of the dropdown with the top corner of the button, if 'bottom' will match the bottom corner for the dropdown to the bottom corner of the button */ DropdownButton.propTypes = { options: PropTypes.arrayOf(PropTypes.string).isRequired, selected: PropTypes.number, onChange: PropTypes.func.isRequired, horizontalAlignment: PropTypes.oneOf(['left', 'right']), verticalAlignment: PropTypes.oneOf(['top', 'bottom']) }; DropdownButton.defaultProps = { selected: 0, horizontalAlignment: 'right', verticalAlignment: 'top' }; export default DropdownButton; × Search results Close "},"node_modules_kamb-wc-widget-components_src_Header_Header.jsx.html":{"id":"node_modules_kamb-wc-widget-components_src_Header_Header.jsx.html","title":"Source: node_modules/kamb-wc-widget-components/src/Header/Header.jsx","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: node_modules/kamb-wc-widget-components/src/Header/Header.jsx import React, { Component } from 'react'; import PropTypes from 'prop-types'; import { coreLibrary, widgetModule } from 'kambi-widget-core-library'; import styles from './Header.scss'; /** * Header component, used to create standard headers, this component changes its default behavior based on coreLibrary.pageInfo. * If pageInfo.pageType is \"home\" the header is white background with grey text, otherwise the widget becomes collapsable and the header becomes black with white text. * These defaults are overridable by the props * @memberof widget-components */ class Header extends Component { /* * Constructs. * @param {object} props Header properties */ constructor ( props ) { super(props); this.state = { hidden: this.props.hidden, isHome: coreLibrary.pageInfo.pageType === 'home' }; this.toggleHeader = this.toggleHeader.bind(this); } /* * Called after mounting component */ componentDidMount () { if ( this.state.hidden ) { // Collapse widget if needed by initial state widgetModule.setWidgetHeight(this.headerHeight); } } get headerHeight() { if (this.headerElement) { return this.headerElement.offsetHeight; } else if (this.props.collapsable) { return 40; } return 37; } /* * Collapses or expands the widget */ toggleHeader () { if ( this.props.collapsable === true || ( this.props.collapsable == null &amp;&amp; !this.state.isHome )) { this.setState({ hidden: !this.state.hidden }); if ( !this.state.hidden ) { widgetModule.setWidgetHeight(this.headerHeight); if (this.props.onCollapse) { this.props.onCollapse(); } } else { widgetModule.adaptWidgetHeight(); if (this.props.onExpand) { this.props.onExpand(); } } } } /* * Creates Header template. * @returns {XML} */ render () { // Default classes to be added to all headers let cssClasses = `${styles.general} KambiWidget-card-support-text-color KambiWidget-card-header-border`; // If we have custom classes disregard default styling and load custom classes if ( typeof this.props.customClasses === 'string') { cssClasses = this.props.customClasses; } else { // Add classes depending on pageInfo if (!this.state.isHome) { // eslint-disable-line cssClasses += ` KambiWidget-header ${styles.kwNotHome}`; } } return ( &lt;header ref={(headerElement) =&gt; { this.headerElement = headerElement }} className={cssClasses} onClick={this.toggleHeader}&gt; {this.props.children} &lt;/header&gt; ) } } /** * @property children {ReactElement} Elements to be placed inside the header * @property [collapsable] {boolean} Sets header as collapsable. If not provided will be collapsable if coreLibrary.pageInfo.pageType !== 'home' * @property [hidden] {boolean} if true the widget will start collapsed * @property [onCollapse] {Function} callback invoked when the widget collapses * @property [onExpand] {Function} callback invoked when the widget uncollapses * @property [customClasses] {string} Defaults to false. If provided adds these CSS classes to the header instead of adding classes based on coreLibrary.pageInfo.pageType (black header if pageType !== 'home') */ Header.propTypes = { children: PropTypes.node.isRequired, collapsable: PropTypes.bool, hidden: PropTypes.bool, onCollapse: PropTypes.func, onExpand: PropTypes.func, customClasses: PropTypes.string }; export default Header; × Search results Close "},"node_modules_kamb-wc-widget-components_src_OutcomeButton_OutcomeButton.jsx.html":{"id":"node_modules_kamb-wc-widget-components_src_OutcomeButton_OutcomeButton.jsx.html","title":"Source: node_modules/kamb-wc-widget-components/src/OutcomeButton/OutcomeButton.jsx","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: node_modules/kamb-wc-widget-components/src/OutcomeButton/OutcomeButton.jsx import React, { Component } from 'react' import PropTypes from 'prop-types' import { coreLibrary, widgetModule, utilModule, updatesModule, } from 'kambi-widget-core-library' import OutcomeButtonUI from './OutcomeButtonUI' /* * Returns initial state. * @param {object} outcome Outcome entity * @returns {{selected: boolean}} */ const getInitialState = outcome =&gt; { return { selected: widgetModule.betslipIds.indexOf(outcome.id) !== -1, // information that is compared when getting updated betoffers currentOutcomeInfo: getOutcomeInfo(outcome), } } const getOutcomeInfo = (outcome, suspended = false) =&gt; { return { odds: outcome.odds, oddsAmerican: outcome.oddsAmerican, oddsFractional: outcome.oddsFractional, label: outcome.label, suspended, } } /** * Outcome button component. This component renders an outcome with or without a label. It automatically adds/removes the outcome to/from the betslip when the user clicks the button. Besides that it also automatically rerenders itself when the user changes the odds format * * This component uses the OutcomeButtonUI behind the scenes, if you don't want the automatic functionality mentioned before you should use OutcomeButtonUI * @memberof widget-components */ class OutcomeButton extends Component { /* * Outcome component constructor * @param {object} props Component properties */ constructor(props) { super(props) this.toggleOutcome = this.toggleOutcome.bind(this) // compute initial state this.state = getInitialState(this.props.outcome) this.oddsFormatChangedHandler = () =&gt; this.forceUpdate() this.betoffersUpdatedHandler = this.betoffersUpdatedHandler.bind(this) this.betslipUpdatedHandler = this.betslipUpdatedHandler.bind(this) } /* * Called just before component mounting */ componentDidMount() { this.subscribeToEvents(this.props.event, this.props.outcome) } /* * Called just before changing properties of component * @param {object} nextProps New properties */ componentWillReceiveProps(nextProps) { this.unsubscribeFromEvents(this.props.outcome) this.subscribeToEvents(nextProps.event, nextProps.outcome) this.setState(getInitialState(nextProps.outcome)) } /* * Called just before component unmounting */ componentWillUnmount() { this.unsubscribeFromEvents(this.props.outcome) } shouldComponentUpdate(nextProps, nextState) { // preventing unnecessary updates if ( this.state.selected === nextState.selected &amp;&amp; // deep comparing currentOutcomeInfos Object.keys(this.state.currentOutcomeInfo).filter(key =&gt; { // filter out label and suspended keys for comparison if (key === 'label' || key === 'suspended') { return false } return true }).reduce((acc, key, i, arr) =&gt; { // compare only odds in here, not label or suspended if (acc === true) { return true } return ( nextState.currentOutcomeInfo[key] === this.state.currentOutcomeInfo[key] ) }, false) ) { return false } return true } componentDidUpdate(prevProps, prevState) { if ( prevState.selected !== this.state.selected &amp;&amp; this.props.onSelection != null ) { this.props.onSelection(this.state.selected) } } betslipUpdatedHandler(data) { let selected = false for (let i = 0; i &lt; data.outcomes.length; i++) { const outcome = data.outcomes[i] if (outcome.id === this.props.outcome.id) { selected = true } } this.setState({ selected, }) } /* * Handles updates from the eventUpdatesModule */ betoffersUpdatedHandler(data) { const boid = this.props.outcome.betOfferId let newbo = null if (data.betoffers == null) { return } for (let i = 0; i &lt; data.betoffers.length; i++) { const bo = data.betoffers[i] if (bo.id === boid) { newbo = bo break } } if (newbo == null) { return } let newoutcome = null for (let i = 0; i &lt; newbo.outcomes.length; i++) { const outcome = newbo.outcomes[i] if (outcome.id === this.props.outcome.id) { newoutcome = outcome break } } if (newoutcome == null) { this.setState({ currentOutcomeInfo: null, }) return } const currOutcomeInfo = this.state.currentOutcomeInfo const newOutcomeInfo = getOutcomeInfo(newoutcome, newbo.suspended) // comparing the new outcome with the old one, if they are different update the state let update = false Object.keys(currOutcomeInfo).forEach(key =&gt; { if (currOutcomeInfo[key] !== newOutcomeInfo[key]) { update = true } }) if (update) { this.setState({ currentOutcomeInfo: newOutcomeInfo, }) } } /* * Subscribes to external events related to this component instance * @param {object} outcome Outcome entity */ subscribeToEvents(event, outcome) { updatesModule.subscribe.betslipOutcomes(this.betslipUpdatedHandler) updatesModule.subscribe.oddsFormat(this.oddsFormatChangedHandler) if (this.props.updateOdds !== true) { return } if (event.openForLiveBetting) { updatesModule.subscribe.allLiveBetoffers( event.id, this.betoffersUpdatedHandler ) } else { updatesModule.subscribe.allPreMatchBetoffers( event.id, this.betoffersUpdatedHandler ) } } /* * Unsubscribes from external events related to this component instance * @param {object} outcome Outcome entity */ unsubscribeFromEvents(outcome) { updatesModule.unsubscribe(this.oddsFormatChangedHandler) updatesModule.unsubscribe(this.betslipUpdatedHandler) if (this.props.updateOdds !== true) { return } updatesModule.unsubscribe(this.betoffersUpdatedHandler) } /* * Handles outcome button's click event */ toggleOutcome() { if (this.state.selected) { widgetModule.removeOutcomeFromBetslip(this.props.outcome.id) } else { widgetModule.addOutcomeToBetslip( this.props.outcome.id, this.props.betslipDefaultStake, this.props.betslipUpdateMode, this.props.betslipTrackingName ) } } /* * Properly formatted odds * @returns {number} */ get oddsFormatted() { switch (coreLibrary.oddsFormat) { case 'fractional': return this.state.currentOutcomeInfo.oddsFractional case 'american': let odds = this.state.currentOutcomeInfo.oddsAmerican if (parseFloat(odds, 10) &gt;= 0) { odds = '+' + odds } return odds default: return utilModule.getOddsDecimalValue( this.state.currentOutcomeInfo.odds / 1000 ) } } /* * Button's label * @returns {string|null} */ get label() { if (typeof this.props.label === 'string') { return this.props.label } if (this.props.label === false) { return null } if (this.props.event) { return utilModule.getOutcomeLabel(this.props.outcome, this.props.event) } else { return this.state.currentOutcomeInfo.label } } /* * Returns component's template * @returns {XML} */ render() { // outcomes &lt;= 1.0 do not make sense but still appears in the API sometimes if ( this.state.currentOutcomeInfo == null || this.state.currentOutcomeInfo.odds &lt;= 1000 ) { return &lt;div style={{ display: 'none' }} /&gt; } return ( &lt;OutcomeButtonUI label={this.label} odds={this.oddsFormatted} suspended={this.state.currentOutcomeInfo.suspended} selected={this.state.selected} onClick={this.toggleOutcome} outlineStyle={this.props.outlineStyle} /&gt; ) } } /** * @property outcome {Object} The Outcome object provided by the calls from the offeringModule * @property [event] {Object} the Event object provided by the calls from the offeringModule. If not provided will some types of outcomes may not show the correct label. If the \"label\" prop is false this prop is not used * @property [label=true] {string|boolean} Label to show. If boolean and false don't show any label, only the odds, if boolean and true use the provided event and the outcome to determine the label, if string uses it as the label * @property [updateOdds=false] {boolean} If true will automatically update odds using the Widget API (non stand-alone mode only). This is fairly resource intensive, set it to false if your widget shows many betoffers from different events (showing several for the same event should be fine) * @property [betslipUpdateMode=null] {string} update mode for adding the bet to the betslip, either 'append' (the default) or 'replace' * @property [betslipDefaultStake=null] {string} the stake amount to use when adding the bet to the betslip, user can change this value after adding the bet to the betslip * @property [betslipTrackingName=null] {string} string for tracking bets placed through this button, if not provided uses coreLibrary.args.widgetTrackingName * @property [onSelection=null] {Function(Boolean)} Callback called when the button becomes selected or unselected, the callback receives one boolean parameter with the current selection state. This callback can be fired multiple times per state change */ OutcomeButton.propTypes = { outcome: PropTypes.object.isRequired, event: PropTypes.object.isRequired, label: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]), updateOdds: PropTypes.bool, betslipUpdateMode: PropTypes.string, betslipDefaultStake: PropTypes.number, betslipTrackingName: PropTypes.string, onSelection: PropTypes.func, } OutcomeButton.defaultProps = { label: true, outlineStyle: false, updateOdds: false, betslipUpdateMode: null, betslipDefaultStake: null, betslipTrackingName: null, onSelection: null, } export default OutcomeButton × Search results Close "},"node_modules_kamb-wc-widget-components_src_OutcomeButton_OutcomeButtonUI.jsx.html":{"id":"node_modules_kamb-wc-widget-components_src_OutcomeButton_OutcomeButtonUI.jsx.html","title":"Source: node_modules/kamb-wc-widget-components/src/OutcomeButton/OutcomeButtonUI.jsx","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Source: node_modules/kamb-wc-widget-components/src/OutcomeButton/OutcomeButtonUI.jsx import React, { Component } from 'react' import PropTypes from 'prop-types' import styles from './OutcomeButtonUI.scss' /* eslint-disable react/prefer-stateless-function */ /** * Renders the UI of an outcome button, no * special handling logic. * @memberof widget-components */ class OutcomeButtonUI extends Component { render() { const { label, odds, suspended, selected, onClick, outlineStyle, } = this.props let buttonCssClasses = `KambiBC-mod-outcome KambiWidget-outcome ${ styles.general }` if (outlineStyle) { buttonCssClasses = `${buttonCssClasses} KambiWidget-primary-color ${ styles.outline }` } if (suspended) { buttonCssClasses += ' KambiWidget-outcome--suspended' } else if (selected) { buttonCssClasses = `KambiWidget-outcome ${ styles.general } KambiWidget-outcome--selected ${styles['outline--selected']}` } if (odds === null &amp;&amp; label === null) { throw new Error('Both odds and label cannot be set to null') } return ( &lt;button type=\"button\" role=\"button\" className={buttonCssClasses} disabled={suspended} onClick={onClick} &gt; {odds !== null &amp;&amp; label !== null &amp;&amp; ( &lt;div className=\"KambiWidget-outcome__flexwrap\"&gt; &lt;div className={`KambiWidget-outcome__label-wrapper ${ outlineStyle ? styles['outline__label-wrapper'] : '' }`} &gt; &lt;span className=\"KambiWidget-outcome__label\"&gt;{label}&lt;/span&gt; &lt;span className=\"KambiWidget-outcome__line\" /&gt; &lt;/div&gt; &lt;div className=\"KambiWidget-outcome__odds-wrapper\"&gt; &lt;span className={`KambiWidget-outcome__odds ${ outlineStyle ? styles['outline__odds'] : '' }`} &gt; {odds} &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; )} {odds !== null &amp;&amp; label === null &amp;&amp; ( &lt;div className={`KambiWidget-outcome__odds-wrapper`}&gt; &lt;span className={`KambiWidget-outcome__odds ${ outlineStyle ? styles['outline__odds'] : '' }`} &gt; {odds} &lt;/span&gt; &lt;/div&gt; )} {odds === null &amp;&amp; label !== null &amp;&amp; ( &lt;div className={`KambiWidget-outcome__label-wrapper ${styles.label} ${ outlineStyle ? styles['outline__label-wrapper'] : '' }`} &gt; &lt;span className=\"KambiWidget-outcome__label\"&gt;{label}&lt;/span&gt; &lt;/div&gt; )} &lt;/button&gt; ) } } /** * @property [label=null] {node?} if not defined centralizes the odds in the button, if defined uses this as the label in the button * @property [odds=null] {string?} if not defined centralizes the label in the button, if defined shows the odds in the button (either centralized or on the right side if label is defined) * @property [suspended=false] {boolean} If true the button is greyed out * @property selected {boolean} If true the button is selected, false otherwise. * @property onClick {Function} Callback for when the button is clicked */ OutcomeButtonUI.propTypes = { label: PropTypes.node, odds: PropTypes.string, suspended: PropTypes.bool, selected: PropTypes.bool.isRequired, onClick: PropTypes.func, } OutcomeButtonUI.defaultProps = { odds: null, label: null, suspended: false, selected: false, } export default OutcomeButtonUI × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Global Members FixedList_RenderItemContainerArgs Properties: Name Type Description selected boolean Controls whether item should be rendered as currently selected or normally onClick function Called once item has been clicked onWidth function Called when item width is determined or has been changed children ReactElement Item contents Source: node_modules/kamb-wc-widget-components/src/List/FixedList/FixedList.jsx, line 71 &lt;constant&gt; ScrolledList_ALIGN_ITEMS :string Items alignment constants Type: string Properties: Name Type Default Description LEFT string flex-start List items will be aligned to the left. RIGHT string flex-end List items will be aligned to the right. CENTER string center List items will be centered. SPACE_AROUND string space-around There will be space around all items. SPACE_BETWEEN string space-between There will be space only between items. Source: node_modules/kamb-wc-widget-components/src/List/ScrolledList/ScrolledList.jsx, line 28 Example &lt;ScrolledList alignItems={ScrolledList.ALIGN_ITEMS.SPACE_BETWEEN}&gt;...&lt;/ScrolledList&gt; ScrolledList_RenderButtonArgs Properties: Name Type Description onClick function Click handler disabled boolean Controls whether button should be rendered as disabled or not Source: node_modules/kamb-wc-widget-components/src/List/ScrolledList/ScrolledList.jsx, line 484 ScrolledList_RenderItemContainerArgs Properties: Name Type Description selected boolean Controls whether item should be rendered as currently selected or normally onClick function Called once item has been clicked onWidth function Called when item width is determined or has been changed children ReactElement Item contents Source: node_modules/kamb-wc-widget-components/src/List/ScrolledList/ScrolledList.jsx, line 510 &lt;constant&gt; ScrolledList_SCROLL_TO_ITEM_MODE :string Scroll to selected item modes Type: string Properties: Name Type Default Description TO_LEFT string to-left Selected item will be the first object on the left side of eye shot CENTER string center Selected item will be at the center of eye shot Source: node_modules/kamb-wc-widget-components/src/List/ScrolledList/ScrolledList.jsx, line 67 Example &lt;ScrolledList scrollToItemMode={ScrolledList.SCROLL_TO_ITEM_MODE.TO_LEFT}&gt;...&lt;/ScrolledList&gt; TabPagination_RenderTabListArgs Properties: Name Type Description selected number Initially selected list item (tab) onItemClick function Item clicked handler. Called with item's index argument. children Array.&lt;ReactElement&gt; Array of list items (tabs) Source: node_modules/kamb-wc-widget-components/src/TabPagination/TabPagination.jsx, line 100 Type Definitions FixedList_RenderItemContainer(args) Parameters: Name Type Description args FixedList_RenderItemContainerArgs Contains properties which will control the container Source: node_modules/kamb-wc-widget-components/src/List/FixedList/FixedList.jsx, line 53 Returns: ReactElement Examples Using custom item container ({selected, onClick, onWidth, children}) =&gt; &lt;CustomItemContainer selected={selected} onClick={onClick} onWidth={onWidth}&gt; {children} &lt;/CustomItemContainer&gt; Shorthand syntax can be used once function arguments and component properties names match. args =&gt; &lt;CustomItemContainer {...args}&gt;{args.children}&lt;/CustomItemContainer&gt; ScrolledList_RenderButton(args) Should return rendered prev/next scroll button. Parameters: Name Type Description args ScrolledList_RenderButtonArgs Contains properties which will control the button Source: node_modules/kamb-wc-widget-components/src/List/ScrolledList/ScrolledList.jsx, line 471 Returns: ReactElement Examples Using custom button for next/prev. ({onClick, disabled}) =&gt; &lt;CustomButton onClick={onClick} disabled={disabled} /&gt; Shorthand syntax can be used once function arguments and component properties names match. args =&gt; &lt;CustomButton {...args} /&gt; ScrolledList_RenderItemContainer(args) Should return rendered item container. Container is responsible for receiving clicks, properly rendering selected state and optionally hover. Parameters: Name Type Description args ScrolledList_RenderItemContainerArgs Container properties which will control the container Source: node_modules/kamb-wc-widget-components/src/List/ScrolledList/ScrolledList.jsx, line 490 Returns: ReactElement Examples Using custom item container ({selected, onClick, onWidth, children}) =&gt; &lt;CustomItemContainer selected={selected} onClick={onClick} onWidth={onWidth}&gt; {children} &lt;/CustomItemContainer&gt; Shorthand syntax can be used once function arguments and component properties names match. args =&gt; &lt;CustomItemContainer {...args}&gt;{args.children}&lt;/CustomItemContainer&gt; TabPagination_OnTabChange(idx) Called after switching tabs. Parameters: Name Type Description idx number Tab index Source: node_modules/kamb-wc-widget-components/src/TabPagination/TabPagination.jsx, line 107 Example idx =&gt; console.log('currently selected tab: ' + idx) TabPagination_RenderTab(idx) Renders tab for given index. The tab will be placed inside upper tab bar. Parameters: Name Type Description idx number Tab index Source: node_modules/kamb-wc-widget-components/src/TabPagination/TabPagination.jsx, line 61 Returns: ReactElement Example idx =&gt; &lt;div style={{width: 50, height: 50}}&gt;Tab &lt;strong&gt;#{idx}&lt;/strong&gt;&lt;/div&gt; TabPagination_RenderTabList(args) Renders upper tab list. Parameters: Name Type Description args TabPagination_RenderTabListArgs Contains properties which will control tab bar behaviour Source: node_modules/kamb-wc-widget-components/src/TabPagination/TabPagination.jsx, line 70 Returns: ReactElement Examples Using custom tab bar component ({selected, onItemClick, children}) =&gt; &lt;CustomTabBar selected={selected} onItemClick={onItemClick}&gt; {children} &lt;/CustomTabBar&gt; Shorthand syntax can be used once function arguments and component properties names match. args =&gt; &lt;CustomTabBar {...args}&gt;{args.children}&lt;/CustomTabBar&gt; Usage of build-in FixedList component as tab bar. args =&gt; &lt;FixedList {...args}&gt;{args.children}&lt;/FixedList&gt; Advanced usage of ScrolledList component as tab bar. args =&gt; &lt;ScrolledList {...args} alignItems={ScrolledList.ALIGN_ITEMS.LEFT} step={3}&gt; {args.children} &lt;/ScrolledList&gt; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Modules Classes BlendedBackground DropdownButton FixedList Header OutcomeButton OutcomeButtonUI ScrolledList TabPagination Namespaces widget-components × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Classes Classes BlendedBackground DropdownButton FixedList Header OutcomeButton OutcomeButtonUI ScrolledList TabPagination Namespaces widget-components × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Namespaces Classes BlendedBackground DropdownButton FixedList Header OutcomeButton OutcomeButtonUI ScrolledList TabPagination Namespaces widget-components × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Tutorials Classes BlendedBackground DropdownButton FixedList Header OutcomeButton OutcomeButtonUI ScrolledList TabPagination Namespaces widget-components × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Glomo Widget Platform Platform for creating widgets using Kambi's Widget API for use in Kambi's Sportsbook applications. This platform is divided into 3 libraries, they are all available through NPM. See the Tutorials section to get started. Documentation Issues/Questions Libraries kambi-widget-core-library Core package with wrappers around Kambi's Widget API (which allows interaction with the Sportsbook) and Offering API (which you use to fetch data from the server) as well as an internationalization API. This package also includes the build process for the widget projects and a built-in web server for local development. kamb-wc-widget-components Reusable UI components that follow Kambi's design. This package is optional. × Search results Close "},"BlendedBackground.html":{"id":"BlendedBackground.html","title":"Class: BlendedBackground","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Class: BlendedBackground BlendedBackground Displays a background image which is blended with actual operator's color theme. new BlendedBackground() Source: node_modules/kamb-wc-widget-components/src/BlendedBackground/BlendedBackground.jsx, line 10 Members &lt;static&gt; propTypes Properties: Name Type Description backgroundUrl String provides path to backgroundImage blendWidthOperatorColor Boolean determines if background should be blended with operator color. (Normally not wanted if providing own background image) Source: node_modules/kamb-wc-widget-components/src/BlendedBackground/BlendedBackground.jsx, line 90 × Search results Close "},"module-coreLibrary.html":{"id":"module-coreLibrary.html","title":"Module: coreLibrary","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Module: coreLibrary Main module that holds the other modules as well as widget related configurations Source: src/coreLibrary.js, line 11 Members &lt;static&gt; _widgetTrackingName The name sent to Kambi API for analytics data collection Source: src/coreLibrary.js, line 387 &lt;static&gt; browser :String Name of the browser that is running the widget Type: String Source: src/coreLibrary.js, line 121 &lt;static&gt; browserVersion :String Browser version Type: String Source: src/coreLibrary.js, line 127 &lt;static&gt; cssLoadedPromise :Promise Promise that is resolved when all the CSS has finished loading Type: Promise Source: src/coreLibrary.js, line 404 &lt;static&gt; embeddedMethods Methods returned by the widget when it's function is called in Embedded mode by adding more methods here the widget can set up communication with the rest of the page Source: src/coreLibrary.js, line 416 &lt;static&gt; initialized :Boolean If true the coreLibrary has been initialized Type: Boolean Source: src/coreLibrary.js, line 115 &lt;static&gt; kambiDefaultClasses An array with the default classes that should be added to HTML tag Source: src/coreLibrary.js, line 132 &lt;static&gt; widgetApi :Object a direct reference to the Kambi's WidgetApi (wapi) Type: Object Source: src/coreLibrary.js, line 410 &lt;inner&gt; apiVersions :Object Versions of the API provided by the sportsbook Type: Object Properties: Name Type Description client String libs String wapi String Source: src/coreLibrary.js, line 362 &lt;inner&gt; args args object for the widget, merges the default args provided by coreLibrary.init() with the ones that come from the sportsbook. There are some pre-defined arguments that all widgets accept, but most of them are widget-defined. Properties: Name Type Description widgetTrackingName String Sets widget tracking name for analytics purposes. This tracking name is used for calls to add bets to the betslip customCssUrl String URL to a CSS file to add to the page, expressions like \"{customer}\" are replaced with their values in coreLibrary.config. This is useful to load different stylesheets based on operator name. Example: Say coreLibrary.config.customer is 'kambi', then if this argument was set: { customCssUrl: \"https://someurl.com/customcss/{customer}/style.css\" } It would load this CSS file and add it to the page: https://someurl.com/customcss/kambi/style.css customCssUrlFallback String fallback if the fetching of customCssUrl fails onHeightChange function Callback called when an embedded widget height changes (by calling either widgetModule.setWidgetHeight or widgetModule.adaptWidgetHeight) onWidgetRemoved function Callback called when an widget removes itself (by calling widgetModule.removeWidget) onWidgetLoaded function Callback called when an widget finishes loading. This needs to be called by the widget itself after rendering its content onWidgetNavigateClient function Callback called when an widget wants to navigate to another page. In embedded mode the widget will NOT call the WidgetAPI.navigateClient, instead it will call this method with the path of the page. Second parameter is coreLibrary.args.widgetTrackingName conditionalArgs Array.&lt;Object&gt; Optional, specify arguments to be applied based on some condition based in the values inside coreLibrary.config or coreLibrary.pageInfo widgetTrackingName String | null navigateClient Optional, callback called when the widget tries to perform internal Kambi Sportsbook navigation example: conditionalArgs: [ // if coreLibrary.config.currency is 'EUR' apply { euro: true, dollars: false } to the arguments { config: { currency: 'EUR' }, args: { euro: true, dollars: false } }, // if market is 'IT' AND offering is 'IT' apply { italian: true } to the arguments { config: { market: 'IT', offering: 'IT' }, args: { italian: true } }, ] Source: src/coreLibrary.js, line 230 &lt;inner&gt; config :Object Config object. This data comes from the sportsbook and should not be manually changed. When in running the widget stand alone this values are retrieved from ./src/mockSetupData.json Type: Object Properties: Name Type Description apiBaseUrl String url of the offering api to use auth Boolean channelId Number currency String what currency to use customer String the customer to use with the offering API device String what kind of device does the user have. Possible values: 'desktop', 'mobile' locale String locale of the user, example: 'en_GB', 'sv_SE' market String market to use with the offering API. oddsFormat String the odds format to show. Possible values: 'decimal', 'fractional', 'american'. To listen to changes to this value use eventsModule.subscribe('ODDS:FORMAT', eventHandlerFn); offering String the offering to use with the offering API routeRoot String streamingAllowedForPlayer Boolean client_id Number version String Source: src/coreLibrary.js, line 138 &lt;inner&gt; pageInfo :Object Information about the page that the widget is being loaded from Type: Object Properties: Name Type Description leaguePaths Array(String) array with league paths. Example:['football/england/premier_league'] pageParam String parameter for this page. For a page of type 'filter' an example would be 'football/england/premier_league' pageTrackingPath String the path in the url for this page. For example: '/filter/football/england/premier_league' pageType String type of the page, examples: 'home', 'filter' Source: src/coreLibrary.js, line 316 &lt;inner&gt; rootElement :HTMLElement Element that should be used as root to render the widget from. Widgets should render only inside this element Type: HTMLElement Source: src/coreLibrary.js, line 347 Methods &lt;static&gt; getData(url) Makes a AJAX request and parses its response as JSON Parameters: Name Type Description url String Source: src/coreLibrary.js, line 682 Returns: resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function Type Promise &lt;static&gt; getFile(url) Makes a AJAX request and parses its response as text Parameters: Name Type Description url String Source: src/coreLibrary.js, line 700 Returns: resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function Type Promise &lt;static&gt; init(defaultArgs) Initializes the Kambi api Uses ./src/mockSetupData.json as coreLibrary.configs if not loaded inside the sportsbook (ie opened the widget directly). Parameters: Name Type Description defaultArgs Object arguments to be used if they are not provided by the sportsbook Source: src/coreLibrary.js, line 426 Returns: resolved when everything is ready. If an error happens during fetching the error can be catched in a .catch() function Type Promise × Search results Close "},"module-offeringModule.html":{"id":"module-offeringModule.html","title":"Module: offeringModule","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Module: offeringModule Module with methods to request data from the offering API The offering API has information concerning events (matches, competations) and their respective betoffers as well as live data if available All methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure Source: src/Module/offeringModule.js, line 3 Methods &lt;static&gt; doRequest(requestPath, params, version, noCache) Makes a request to provided path setting the appropriated URL parameters. Usually this method should not be called directly, unless you want to access an endpoint that is not available in the other methods The final url looks like: coreLibrary.config.apiBaseUrl + version + coreLibrary.config.offering + requestPath Example (same as calling offeringModule.getLiveEvents() but forcing to use Portugal Portuguese locale) doRequest('/event/live/open.json' { lang: 'pt_PT' }); this call would fetch this url: https://api.kambi.com/offering/api/v2/kambi/event/live/open.json?lang=pt_PT&amp;market=kambi&amp;client_id=2&amp;include=&amp;betOffers=COMBINED&amp;categoryGroup=COMBINED&amp;displayDefault=true&amp;nocache=1476973932524 Parameters: Name Type Description requestPath string the path to the request params object params to use, can override the parameters this method usually sets version number | string which version of the API to use. Some endpoints are 'v2' and some are 'v3' noCache boolean if true will add a cache-busting URL parameter. Defaults to true Source: src/Module/offeringModule.js, line 242 Returns: Type Promise &lt;static&gt; getEvent(eventId) Requests and event from api Parameters: Name Type Description eventId String The event id we need to fetch Source: src/Module/offeringModule.js, line 192 Returns: Type Promise &lt;static&gt; getEventsByFilter(filter, params) Get events by filter, only returns the main betoffer for the event. To get all betoffers use getEvent() or getLiveEvent() Parameters: Name Type Description filter String Filter string, eg: football params Object Request relevant parameters Source: src/Module/offeringModule.js, line 37 Returns: Type Promise &lt;static&gt; getGroup(groupId) Get group information. Parameters: Name Type Description groupId Number | String Group id Source: src/Module/offeringModule.js, line 26 Returns: Type Promise &lt;static&gt; getGroupEvents(groupId) Get group events Parameters: Name Type Description groupId number | string Group id Source: src/Module/offeringModule.js, line 16 Returns: Type Promise &lt;static&gt; getHighlight() Request the highlight resource which is what is shown under the \"Popular\" section in the Sportsbook Source: src/Module/offeringModule.js, line 208 Returns: Type Promise &lt;static&gt; getLiveEvent(eventId) Returns a live event Parameters: Name Type Description eventId Number | String The event id we need to fetch Source: src/Module/offeringModule.js, line 131 Returns: Type Promise &lt;static&gt; getLiveEvents() Get all live events, only returns the main betoffer for the event. To get all betoffers use getEvent() or getLiveEvent() Source: src/Module/offeringModule.js, line 102 Returns: Type Promise &lt;static&gt; getLiveEventsByFilter(filter) Get live events by filter, only returns the main betoffer for the event. To get all betoffers use getEvent() or getLiveEvent() Parameters: Name Type Description filter String Filter string Source: src/Module/offeringModule.js, line 149 Returns: Type Promise × Search results Close "},"module-statisticsModule.html":{"id":"module-statisticsModule.html","title":"Module: statisticsModule","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Module: statisticsModule Module to access statistics API The statistics API has information concerning historical data of events (matches, competitions) All methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure Source: src/Module/statisticsModule.js, line 3 Methods &lt;static&gt; doRequest(path) Performs the statistics API requests Parameters: Name Type Description path String path of the desired resource, for example /leaguetable/football/england/premier_league.json' Source: src/Module/statisticsModule.js, line 53 Returns: Type Promise &lt;static&gt; getHeadToHeadStatistics(eventId) Requests H2H statistics data from api. Parameters: Name Type Description eventId String | Number id of a match Source: src/Module/statisticsModule.js, line 35 Returns: Type Promise &lt;static&gt; getLeagueTableStatistics(filter) Requests league table statistics data from api. Parameters: Name Type Description filter String a filter string to a competition. Example 'football/england/premier_league' Source: src/Module/statisticsModule.js, line 16 Returns: Type Promise &lt;static&gt; getTeamPerformanceStatistics(eventId) Requests TPI statistics data from api. Parameters: Name Type Description eventId String | Number id of a match Source: src/Module/statisticsModule.js, line 44 Returns: Type Promise × Search results Close "},"module-translationModule.html":{"id":"module-translationModule.html","title":"Module: translationModule","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Module: translationModule Module with internationalization methods Provides a very simple internationalization mechanism that is not relient in any library. The loading of the right internationalization JSON file is handled automatically Source: src/Module/translationModule.js, line 5 Methods &lt;static&gt; getTranslation(key, args) Returns translated string based of a provided key. Parameters: Name Type Argument Description key String Key to fetch translation for args String &lt;repeatable&gt; arguments to replace inside the translated string Source: src/Module/translationModule.js, line 24 Returns: the localized string Type String Example en_GB.json: { \"welcomeUserToPlace\": \"Welcome {0} to {1}\" } Javascript: getTranslation('welcomeUserToPlace', 'Daniel', 'Stadium') =&gt; 'Welcome Daniel to Stadium' × Search results Close "},"module-updatesModule.html":{"id":"module-updatesModule.html","title":"Module: updatesModule","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Module: updatesModule Module with methods to set up subscription for different kinds of updates (betoffer data, odds format change and so on) Source: src/Module/updatesModule.js, line 4 × Search results Close "},"module-utilModule.html":{"id":"module-utilModule.html","title":"Module: utilModule","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Module: utilModule Module with utility functions Source: src/Module/utilModule.js, line 38 Methods &lt;static&gt; clone(x) Returns deep copy of given object. Parameters: Name Type Description x object Object to be cloned Source: src/Module/utilModule.js, line 97 &lt;static&gt; equals(x, y) Checks deep equality of two object. Parameters: Name Type Description x object First object y object Second object Source: src/Module/utilModule.js, line 72 Returns: Type boolean &lt;static&gt; getOddsDecimalValue(odds) Get decimal formatted odds. Parameters: Name Type Description odds Number Odds number Source: src/Module/utilModule.js, line 123 Returns: Type Number &lt;static&gt; getOutcomeLabel(outcome, event) Returns the outcome label translated. Parameters: Name Type Description outcome Object A betoffer outcome object event Object Event object Source: src/Module/utilModule.js, line 139 Returns: Type string × Search results Close "},"module-widgetModule.html":{"id":"module-widgetModule.html","title":"Module: widgetModule","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Module: widgetModule Module with methods to manipulate the widget and interact with the sportsbook Source: src/Module/widgetModule.js, line 1 Members &lt;static&gt; events Object in which you can add event listeners for Kambi Widget API events Deprecated: use eventsModule Valid events listeners: 'WIDGET:HEIGHT': Widget height changed 'OUTCOME:REMOVED:{outcomeId}': Outcome with {outcomeId} removed 'OUTCOME:ADDED:{outcomeId}': Outcome with {outcomeId} added 'OUTCOME:UPDATE:{outcomeId}': Outcome with {outcomeId} updated 'WIDGET:ARGS': Widget args changed 'PAGE:INFO': Page info changed 'ODDS:FORMAT': Odds format changed 'CLIENT:CONFIG': Client config changed 'USER:LOGGED_IN': User logged in changed 'LIVE:EVENT:{eventId}': Live event statistics changed 'LIVE:EVENT:{eventId}:REMOVED': Not a live event anymore 'LIVE:EVENTDATA:{eventId}': Live event's statistics changed 'LIVE:EVENTDATA:{eventId}:REMOVED': Not a live event anymore 'LIVE:EVENTS': Live events list changed Source: src/Module/widgetModule.js, line 65 Example widgetModule.events .subscribe('OUTCOME:ADDED:' + outcome.id, ( data ) =&gt; { ... }); Methods &lt;static&gt; adaptWidgetHeight() tries to adapt the widget iframe height to match the content Only works if the html and body tags don't have height: 100% styling rule Source: src/Module/widgetModule.js, line 289 &lt;static&gt; addOutcomeToBetslip(outcomes, stakes, updateMode, source) Adds an outcomes to the betslip Parameters: Name Type Description outcomes Array.&lt;Number&gt; | Number ids of the outcomes to add stakes Array.&lt;Number&gt; | Number the value of the stakes to add (referencing the ids in the outcomes parameter) updateMode String defaults to 'append', but also accepts 'replace' source String Source: src/Module/widgetModule.js, line 394 &lt;static&gt; createFilterUrl(destination) Creates a filter url from given array Parameters: Name Type Description destination Array Source: src/Module/widgetModule.js, line 166 Returns: Type string Example destination = ['/football/europa_league/', '/football/world_cup_qualifying_-_europe/']; &lt;static&gt; createUrl(path, optionalRoot) Creates url from given path and optionalRoot Parameters: Name Type Description path String optionalRoot String Source: src/Module/widgetModule.js, line 155 Returns: Type String &lt;static&gt; enableWidgetTransition(enableTransition) Enables/disables animations of changing the height of the iframe Parameters: Name Type Description enableTransition boolean new state to be Source: src/Module/widgetModule.js, line 326 &lt;static&gt; getPageType() Returns the page type page type Source: src/Module/widgetModule.js, line 240 Returns: Type String &lt;static&gt; navigateClient(destination) Navigates to a page in the sportsbook Parameters: Name Type Description destination String | Array fragment part of the URL to navigate to (the part after the # in the URL) Source: src/Module/widgetModule.js, line 527 &lt;static&gt; navigateToEvent(eventId) Method to navigate to a pre-live event page Parameters: Name Type Description eventId number Source: src/Module/widgetModule.js, line 362 &lt;static&gt; navigateToFilter(filterParams) Method to navigate to a filter page Parameters: Name Type Description filterParams String Source: src/Module/widgetModule.js, line 370 &lt;static&gt; navigateToLiveEvent(eventId) Method to navigate to a live event page Parameters: Name Type Description eventId number Source: src/Module/widgetModule.js, line 354 &lt;static&gt; navigateToLiveEvents() Navigates to the live events page Source: src/Module/widgetModule.js, line 383 &lt;static&gt; removeOutcomeFromBetslip(outcomes) Removes outcomes from betslip Parameters: Name Type Description outcomes Array.&lt;Number&gt; | Number ids of the outcomes to remove form the betslip Source: src/Module/widgetModule.js, line 445 &lt;static&gt; removeWidget() Call api to remove widget from the sportsbook Source: src/Module/widgetModule.js, line 337 &lt;static&gt; requestBetslipOutcomes() Requests betslip outcomes Source: src/Module/widgetModule.js, line 465 &lt;static&gt; requestClientConfig() Requests client config Source: src/Module/widgetModule.js, line 486 &lt;static&gt; requestOddsAsAmerican(odds) Requests american odds Parameters: Name Type Description odds Number Source: src/Module/widgetModule.js, line 502 Returns: Type Promise &lt;static&gt; requestOddsAsFractional(odds) Requests fractional odds Parameters: Name Type Description odds Number Source: src/Module/widgetModule.js, line 515 Returns: Type Promise &lt;static&gt; requestOddsFormat() Requests odds format Source: src/Module/widgetModule.js, line 493 &lt;static&gt; requestPageInfo() Requests page info Source: src/Module/widgetModule.js, line 472 &lt;static&gt; requestSetup(callback) Makes widget api request for setupdata Parameters: Name Type Description callback fn Callback Source: src/Module/widgetModule.js, line 260 &lt;static&gt; requestWidgetArgs() Requests widget args Source: src/Module/widgetModule.js, line 479 &lt;static&gt; requestWidgetHeight() Requests widget height from widget api Source: src/Module/widgetModule.js, line 267 &lt;static&gt; setWidgetHeight(height) Set widget iframe height Parameters: Name Type Description height Number the height in pixels Source: src/Module/widgetModule.js, line 275 × Search results Close "},"widget-components.html":{"id":"widget-components.html","title":"Namespace: widget-components","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Namespace: widget-components widget-components Reusable React Components It is not necessary to make the whole widget in React in order to use these components, they can be mixed with non React code as necessary. Source: node_modules/kamb-wc-widget-components/src/components.js, line 1 Examples // this example shows how to use the Header component without using JSX import React from 'react'; import ReactDOM from 'react-dom'; import { Header } 'kamb-wc-widget-components'; // Basic React API: React.createElement(Component, props, children) // check widget-components.Header documentation for all the options const header = React.createElement( Header, { collapsable: false }, 'This is the Header title' ) // ReactDOM API: ReactDOM.render(reactElement, HTMLElement) // places the Header in the page: ReactDOM.render(header, document.getElementById('header')) // this example shows how to use the Header component using JSX // note that JSX only works in .jsx files import React from 'react'; import ReactDOM from 'react-dom'; import { Header } 'kamb-wc-widget-components'; ReactDOM.render( &lt;Header collapsable={false}&gt; This is the Header title &lt;/Header&gt; , document.getElementById('header')) Classes DropdownButton FixedList Header OutcomeButton OutcomeButtonUI ScrolledList TabPagination × Search results Close "},"widget-components.DropdownButton.html":{"id":"widget-components.DropdownButton.html","title":"Class: DropdownButton","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Class: DropdownButton widget-components~ DropdownButton Component for creating a button that when clicked shows a menu based in the provided options. new DropdownButton() Source: node_modules/kamb-wc-widget-components/src/DropdownButton/DropdownButton.jsx, line 11 Members &lt;static&gt; propTypes Properties: Name Type Argument Default Description options Array.&lt;string&gt; Required. Options to show when the user clicks the button, translations are not applied onChange function Required. Function to be invoked when the user clicks an option, receives the index of the option as an argument. If the user clicks the currently selected option this function is not invoked selected number &lt;optional&gt; 0 Defines which option should be checked upon component creation horizontalAlignment 'left' | 'right' &lt;optional&gt; 'right' Horizontal alignment of the dropdown box. If 'left' will match the left corner of the dropdown with the left corner of the button, if 'right' will match the right corner for the dropdown to the right corner of the button. If widget width is smaller than 925 the dropdown will ignore this option and will cover the full width of the widget verticalAlignment 'top' | 'bottom' &lt;optional&gt; 'top' Vertical alignment of the dropdown box. If 'top' will match the top corner of the dropdown with the top corner of the button, if 'bottom' will match the bottom corner for the dropdown to the bottom corner of the button Source: node_modules/kamb-wc-widget-components/src/DropdownButton/DropdownButton.jsx, line 146 × Search results Close "},"widget-components.FixedList.html":{"id":"widget-components.FixedList.html","title":"Class: FixedList","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Class: FixedList widget-components~ FixedList Horizontal list component. Items will be stretched or shrunken to fit the container. new FixedList() Source: node_modules/kamb-wc-widget-components/src/List/FixedList/FixedList.jsx, line 16 Members &lt;static&gt; propTypes Properties: Name Type Argument Default Description children Array.&lt;ReactElement&gt; &lt;optional&gt; Items list onItemClick function &lt;optional&gt; Item click handler. Called with item index argument. selected number &lt;optional&gt; 0 Initially selected item index renderItemContainer FixedList_RenderItemContainer &lt;optional&gt; Function capable of rendering item container. Renders Kambi-styled item container by default. Source: node_modules/kamb-wc-widget-components/src/List/FixedList/FixedList.jsx, line 85 × Search results Close "},"widget-components.Header.html":{"id":"widget-components.Header.html","title":"Class: Header","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Class: Header widget-components~ Header Header component, used to create standard headers, this component changes its default behavior based on coreLibrary.pageInfo. If pageInfo.pageType is \"home\" the header is white background with grey text, otherwise the widget becomes collapsable and the header becomes black with white text. These defaults are overridable by the props new Header() Source: node_modules/kamb-wc-widget-components/src/Header/Header.jsx, line 18 Members &lt;static&gt; propTypes Properties: Name Type Argument Description children ReactElement Elements to be placed inside the header collapsable boolean &lt;optional&gt; Sets header as collapsable. If not provided will be collapsable if coreLibrary.pageInfo.pageType !== 'home' hidden boolean &lt;optional&gt; if true the widget will start collapsed onCollapse function &lt;optional&gt; callback invoked when the widget collapses onExpand function &lt;optional&gt; callback invoked when the widget uncollapses customClasses string &lt;optional&gt; Defaults to false. If provided adds these CSS classes to the header instead of adding classes based on coreLibrary.pageInfo.pageType (black header if pageType !== 'home') Source: node_modules/kamb-wc-widget-components/src/Header/Header.jsx, line 107 × Search results Close "},"widget-components.OutcomeButton.html":{"id":"widget-components.OutcomeButton.html","title":"Class: OutcomeButton","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Class: OutcomeButton widget-components~ OutcomeButton Outcome button component. This component renders an outcome with or without a label. It automatically adds/removes the outcome to/from the betslip when the user clicks the button. Besides that it also automatically rerenders itself when the user changes the odds format This component uses the OutcomeButtonUI behind the scenes, if you don't want the automatic functionality mentioned before you should use OutcomeButtonUI new OutcomeButton() Source: node_modules/kamb-wc-widget-components/src/OutcomeButton/OutcomeButton.jsx, line 45 Members &lt;static&gt; propTypes Properties: Name Type Argument Default Description outcome Object The Outcome object provided by the calls from the offeringModule event Object &lt;optional&gt; the Event object provided by the calls from the offeringModule. If not provided will some types of outcomes may not show the correct label. If the \"label\" prop is false this prop is not used label string | boolean &lt;optional&gt; true Label to show. If boolean and false don't show any label, only the odds, if boolean and true use the provided event and the outcome to determine the label, if string uses it as the label updateOdds boolean &lt;optional&gt; false If true will automatically update odds using the Widget API (non stand-alone mode only). This is fairly resource intensive, set it to false if your widget shows many betoffers from different events (showing several for the same event should be fine) betslipUpdateMode string &lt;optional&gt; null update mode for adding the bet to the betslip, either 'append' (the default) or 'replace' betslipDefaultStake string &lt;optional&gt; null the stake amount to use when adding the bet to the betslip, user can change this value after adding the bet to the betslip betslipTrackingName string &lt;optional&gt; null string for tracking bets placed through this button, if not provided uses coreLibrary.args.widgetTrackingName onSelection function &lt;optional&gt; null Callback called when the button becomes selected or unselected, the callback receives one boolean parameter with the current selection state. This callback can be fired multiple times per state change Source: node_modules/kamb-wc-widget-components/src/OutcomeButton/OutcomeButton.jsx, line 307 × Search results Close "},"widget-components.OutcomeButtonUI.html":{"id":"widget-components.OutcomeButtonUI.html","title":"Class: OutcomeButtonUI","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Class: OutcomeButtonUI widget-components. OutcomeButtonUI Renders the UI of an outcome button, no special handling logic. new OutcomeButtonUI() Source: node_modules/kamb-wc-widget-components/src/OutcomeButton/OutcomeButtonUI.jsx, line 12 Members &lt;static&gt; propTypes Properties: Name Type Argument Default Description label node &lt;optional&gt; &lt;nullable&gt; null if not defined centralizes the odds in the button, if defined uses this as the label in the button odds string &lt;optional&gt; &lt;nullable&gt; null if not defined centralizes the label in the button, if defined shows the odds in the button (either centralized or on the right side if label is defined) suspended boolean &lt;optional&gt; false If true the button is greyed out selected boolean If true the button is selected, false otherwise. onClick function Callback for when the button is clicked Source: node_modules/kamb-wc-widget-components/src/OutcomeButton/OutcomeButtonUI.jsx, line 111 × Search results Close "},"widget-components.ScrolledList.html":{"id":"widget-components.ScrolledList.html","title":"Class: ScrolledList","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Class: ScrolledList widget-components~ ScrolledList Horizontal scrolled list component. If items won't fit the container the list will be scrolled. Otherwise if items take less space than the container they will be aligned according to alignItems property. new ScrolledList() Source: node_modules/kamb-wc-widget-components/src/List/ScrolledList/ScrolledList.jsx, line 151 Members &lt;static&gt; propTypes Properties: Name Type Argument Default Description children Array.&lt;ReactElement&gt; &lt;optional&gt; Items list onItemClick function &lt;optional&gt; Item click handler. Called with item index argument. selected number &lt;optional&gt; 0 Initially selected item index step number &lt;optional&gt; 2 Scroll step (items count) alignItems ScrolledList_ALIGN_ITEMS &lt;optional&gt; CENTER Method of aligning items when they take less width than the container has renderPrevButton ScrolledList_RenderButton &lt;optional&gt; Function capable of rendering button responsible for scrolling left. Renders left arrow button by default. renderNextButton ScrolledList_RenderButton &lt;optional&gt; Function capable of rendering button responsible for scrolling right. Renders right arrow button by default. renderItemContainer ScrolledList_RenderItemContainer &lt;optional&gt; Function capable of rendering item container. Renders Kambi-styled item container by default. scrollToItemMode ScrolledList_SCROLL_TO_ITEM_MODE &lt;optional&gt; CENTER Scroll to selected item mode showControls boolean &lt;optional&gt; Decides whether next/prev controls be visible e.g. can be hidden in mobile mode Source: node_modules/kamb-wc-widget-components/src/List/ScrolledList/ScrolledList.jsx, line 530 × Search results Close "},"widget-components.TabPagination.html":{"id":"widget-components.TabPagination.html","title":"Class: TabPagination","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs Class: TabPagination widget-components~ TabPagination Tab Pagination component. Component should receive list of tab contents as children. It will render upper tab bar (for switching tabs). Once a tab is clicked a tab content will be switched. new TabPagination() Source: node_modules/kamb-wc-widget-components/src/TabPagination/TabPagination.jsx, line 18 Members &lt;static&gt; propTypes Properties: Name Type Argument Default Description children Array.&lt;ReactElement&gt; &lt;optional&gt; Tab content elements renderTab TabPagination_RenderTab &lt;optional&gt; Function called in order to render single tab on tab bar. Renders tab index by default. renderTabList TabPagination_RenderTabList &lt;optional&gt; Function called in order to render tab bar. Renders ScrolledList by default. selected number &lt;optional&gt; 0 Currently selected tab index onTabChange TabPagination_OnTabChange &lt;optional&gt; Function called after switching tabs Source: node_modules/kamb-wc-widget-components/src/TabPagination/TabPagination.jsx, line 122 × Search results Close "},"tutorial-1 - Introduction.html":{"id":"tutorial-1 - Introduction.html","title":"Tutorial: 1 - Introduction","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs 1 - Introduction Widgets are self-contained content that can be added to various places in the Kambi client. It provides the possibility for the operator to differentiate the client, to add unique features or content, and to tailor the client to a group of players, or even to individuals. The widget is an html-page loaded inside an iframe inside an operator's sportsbook. Using JavaScript the operator can control what widgets to load in the sportsbook and where/when to display them. Pre-requisites Install Nodejs latest version Run: npm install -g kambi-widget-core-library By running this command you will now have a new command line tool called kambi-widgets-cli which is used for creating new projects Notes: When installing Nodejs you also install the npm command line tool. Make sure that the version of npm you have is 3.0.0 or higher by running: npm --version Version 3.0.0 of npm is included in Nodejs versions 5.0.0 or higher. Creating a New Project Run again to update the kambi-widgets-cli to the latest version (this is necessary only when creating a new project): npm install -g kambi-widget-core-library Run: kambi-widgets-cli init project-name Or if you are planning to use React run: kambi-widgets-cli init-react project-name This process can take a few minutes to download all the dependencies. A new project will be created inside the project-name folder. This project has a very simple example on how to build a widget. Setup an Existing Project Clone the project repository Inside the project folder run: npm install This process can take a few minutes to download all the dependencies. Running the Project in Development Mode Inside the project folder run: npm run start If the build was successful the widget will be running under https://localhost:8080 or http://localhost:8080 depending on your package.json useHttps value (the default is true). See the section 2 - Development for more information. Building a Project for Production Inside the project folder run: npm run build If the build was successful after a few seconds the widgets code will be bundled inside the /dist/ folder. All files of this folder should be deployed to whatever hosting solution you use. The sportsbook needs to point to the index.html file from this folder. See section 3 - Production Builds and Deployment for more information × Search results Close "},"tutorial-2 - Development.html":{"id":"tutorial-2 - Development.html","title":"Tutorial: 2 - Development","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs 2 - Development Running the widget Locally Inside the project folder run: npm run start If the build was successful the widget will be running under http://localhost:8080 and http://&lt;your-local-ip&gt;:8080 after a few seconds. The server that hosts the widgets code runs under port 8080. That url can be opened directly but some widget features will not work (like changing the widget size or adding bets to the betslip), for all features to work the widget needs to be opened inside the Sportsbook. Development Server The build process comes with a built-in development server, when you run npm run start this server is used. It is possible to configure the server by changing the package.json, inside it add a devServer key with any options desired. For example to enable HTTPS: { ... \"devServer\": { \"https\": true } } All server options can be seen in the webpack dev-server documentation To open the widget inside the Sportsbook while in development configure a new widget in the Sportsbook widgetSettings to point to to http://localhost:8080/ or http://&lt;your-local-ip&gt;:8080 HTTPS certificate npm run start starts a built-in webserver that hosts the widgets code for development mode. If HTTPS is enabled it will run with a self-signed certificate that needs to be manually trusted in order to be able to open the widget. Depending on your environment setup you might need to enable HTTPS for the widget because a sportsbook running in HTTPS needs the widgets to also be running in HTTPS. In Chrome and Firefox you can trust the certificate by visiting https://localhost:8080 and https://&lt;your-local-ip&gt;:8080 and hitting advance to accept the certificate. For Microsoft Edge and Internet explorer you need to add the certificate on Windows: Open control panel Open Internet options Select content tab Click on Certificates Select Trusted Root Certification Authorities Clici import Select the certificate from project-folder\\node_modules\\webpack-dev-server\\ssl\\server.crt Project file structure project/ README.md .eslintrc .gitignore .editorconfig LICENSE package.json dist/ node_modules src/ assets/ app.scss index.html index.js mockSetupData.json i18n/ en_GB.json README.md Readme for the project .gitignore, postcss.config.js Configuration files for the project. These files are overwritten everytime the widget is built to make sure that all the widgets have the same files. LICENSE License file of the project package.json NPM configuration file. This file lists metadata about the project as well as all external dependencies (kambi-widget-core-library, kamb-wc-widget-components and others) it uses. This file needs to be modified to update the dependencies versions dist When building the project for production with npm run build the files to be deployed are placed inside this folder node_modules All NPM dependencies used in the project are stored in this folder, if the project seems to be missing or using outdated dependencies delete this folder and run npm install to download fresh versions of all the dependencies src This folder holds the source code for the widget src/app.scss SCSS file with styling rules for this widget, this file is converted to regular CSS which is then included in the page during the build process. SCSS is a superset of CSS and as such all CSS is also valid SCSS, meaning normal CSS can be placed in this file. More information on SCSS here src/index.html The markup of the widget, ideally the widget should only change the &lt;body&gt; section of this file. Additional files/libraries should NOT be included in as &lt;script&gt; tags in the page, instead they should be included by importing them inside index.js, although it is still possible to do so. See the following sections on how to add dependencies to the project src/index.js This is the main javascript file of the project, see the following sections on how to use it src/mockSetupData.json This file is used ONLY when opening the widget OUTSIDE of the Kambi Sportsbook (that means accessing https://localhost:8080/ directly), it mocks values that would normally be passed by the Sportsbook to the widget. By changing values in this file you can test how the widget will look and behave in different configurations, for example in another language. For more information check the API documentation for coreLibrary.config, coreLibrary.args and coreLibrary.pageInfo src/i18n This folder holds all the internationalization JSON files of the widget, these are used by the translationModule. The use of these files are optional if no internationalization is required. If the user locale is not found in this folder it will fallback to en_GB.json. These are all the currently supported locales in the Sportsbook, although they can vary by operator: bg_BG.json, cs_CZ.json, de_DE.json, es_ES.json, es_CO.json, fr_CH.json, lt_LT.json, no_NO.json, ro_RO.json, da_DK.json, el_GR.json, et_EE.json, fr_FR.json, lv_LV.json, pl_PL.json, ru_RU.json, de_AT.json, en_AU.json, fi_FI.json, hu_HU.json, nl_BE.json, pt_BR.json, sv_SE.json, de_CH.json, en_GB.json, fr_BE.json, it_IT.json, nl_NL.json, pt_PT.json, tr_TR.json Core Library By default a widget project uses the kambi-widget-core-library dependency. The version of this dependencies that your widget is using can be updated in the package.json file, it is recommended to periodiacally update to the latest version. The latest version number can be seen in: https://www.npmjs.com/package/kambi-widget-core-library Importing and Exporting Files The widget uses webpack to transpile, minify, concatenate, bundle all the files and their dependencies together. This is all done automatically by the scripts npm run start (which also starts a webserver for development) and npm run build. All the webpack configuration is already done by those scripts and as such no configuration is required by the user. However the way that the files are bundled together requires them to be referenced in the code for them to be included in the final bundle. The entry point of the application is src/index.js, this file needs to reference (import) directly or indirectly all other files used, this means even HTML and CSS files. The template project that is generated by kambi-widgets-cli init shows this: import { coreLibrary, widgetModule, offeringModule } from 'kambi-widget-core-library'; import './index.html'; import './app.scss'; ... As can be seen here, that file imports coreLibrary, widgetModule and offeringModule from kambi-widget-core-library as well as importing the ./index.html and ./app.scss. If those files were not imported they would not be included in the final bundled version (index.html would be missing in the dist folder for example). Imports that start with ./ or ../ mean that they are importing other files in the same project, while those without ./ or ../ are importing files that are dependencies of the project (see next few sections for more information). So it is possible to split the widgets code in multiple javascript files. More information about exports and imports can be seen here and here Basic Code Setup All widgets need to start by calling coreLibrary.init() and passing it the default arguments that the widget receives. These arguments can be overwritten by the Sportsbook (or inside src/mockSetupData.json arguments attribute when running the widget outside the sportsbook). coreLibrary.init() returns a Promise object which is a way to deal with asynchronous requests (all calls to fetch data in kambi-widget-core-library return Promises). You can learn more about Promises here. Examples about Promises can also be seen in section 4 - Fetching Data. coreLibrary .init({ // default arguments title: 'Hello World', }) .then(function() { // retrieved arguments var args = coreLibrary.args // receiving the title through this widget arguments document.getElementById('title').innerText = args.title }) The above code simply sets the header text of the widget to be \"Hello World\" unless it was defined by the Sportsbook (through the args passed to the widget) to be something else. Adding an external Dependency With the basic setup you only have access to the kambi-widget-core-library in the project, which can make it hard to do complex widgets using only plain Javascript. If we wanted to add a library to make our life easier we could do so by adding a &lt;script&gt; tag in the &lt;head&gt; section of the page and using it by accessing the global values it defines, but that is not the recommended way of doing this because it can be hard to keep track of all the dependencies the project will need. As an alternative you can also add dependencies using npm. For example to add jquery to the project all we need to do is run this in the command line: npm install --save jquery and start using it by importing it in the javascript: import { coreLibrary } from 'kambi-widget-core-library' import './index.html' import './app.scss' import $ from 'jquery' coreLibrary .init({ // default arguments title: 'Hello World', }) .then(function() { // retrieved arguments var args = coreLibrary.args // receiving the title through this widget arguments $('#title').text(args.title) }) In this manner it is not necessary change index.html to add javascript libraries and stylesheets. You can see a list of all available libraries in the npm registry It is possible to remove or change the version of a dependency added in this manner by editing package.json Performance considerations Dependencies, especially big ones like Angular and jQuery should be avoided. For example due to the nature of iFrames if a Sportsbook page includes 5 different widgets and each of them loads Angular2 (111 kilobytes minified and gziped) the widget will load all that code 5 times (for a total of 555 kilobytes of Javascript). Even though the Angular bundle can be cached by the browser and downloaded only once, actually parsing and executing the Angular bundle can take a long time, especially in mobile phones The build process of the widget can perform some optimizations to reduce the final widget size when using the React framework (only 3 kilobyte impact). We highly recommend the use of vanilla Javascript or React. See section 8 - Using React and widget-components Common Build Architecture Since all webpack build configuration of the widgets is shared and integrated in the kambi-widget-core-library dependency it is not possible to add more items to the build architecture. For example replacing SCSS with LESS is not possible. We might add some scape hatches in the future to support customizing the webpack configuration to allow modifying the build process, but for now that is not possible. If you need something extra please open an issue in the project's (github page)[https://github.com/kambi-sportsbook-widgets/widget-core-library/issues] ES6 and JSX The project has Babel transpilation step process set up during the build so it supports the full ES6 syntax and JSX for React development in all browsers. These new syntaxes are completely optional and can be ignored completely if so desired. Important: Babel only transpiles ES6 syntax, but not ES6 features like fetch API. New ES6 features need to be polyfilled in to support old browsers (for example IE11 does not support fetch API), the kambi-widget-core-library polyfills ES6 Promises so those can be safely used no matter the target browser. Other polyfills are NOT included to keep file size small. Besides ES6 the build process also supports JSX for React development. The only caveat is that JSX syntax is only supported in .jsx files. Since the entry point of the project is src/index.js that file needs to import another .jsx file in order to enable JSX. See more about this in section 8 - Using React and widget-components. Automated testing The build process also contains an automated testing setup using Jest. Tests files need to be placed under projectRoot/test/ folder and should have the extension of .test.js or .test.jsx To run the tests in the widget folder run: npm run test It is possible can send custom command line flags to Jest by using the -- operator. For example to pass the watch flag to Jest (--watch): npm run test -- --watch × Search results Close "},"tutorial-3 - Production Builds and Deployment.html":{"id":"tutorial-3 - Production Builds and Deployment.html","title":"Tutorial: 3 - Production Builds and Deployment","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs 3 - Production Builds and Deployment Production Build Inside the project folder run: npm run build If the build was successful after a few seconds the widgets code will be bundled inside the /dist/ folder. All files of this folder should be deployed to whatever hosting solution you use. The sportsbook needs to point to the index.html file from this folder. Deployment Copy the files from the /dist/ folder to whatever Content Delivery Network (CDN) you use. When configuring the sportsbook the url should point to the index.html inside this /dist/ folder in your CDN of choice. Information about configuring the widgets inside the Sportsbook can be found in the Kambi Documentation This /dist/ folder contain all files that the widget requires to run and they should all be deployed to your CDN of choice. The core-library is bundled together with your widget's code into this folder. Performance The build process also produces a dist/report.html which contains a visualization of the bundle size split by dependency. You can see what dependencies are consuming the most space in the final bundle and optmize your build by eliminating the biggest offenders. × Search results Close "},"tutorial-4 - Fetching Data.html":{"id":"tutorial-4 - Fetching Data.html","title":"Tutorial: 4 - Fetching Data","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs 4 - Fetching Data Fetching data is done through the Kambi's Offering API and the Kambi's Statistics API. The kambi-widget-core-library offers a wrapper around these API through the offeringModule and the statisticsModule. These modules take care of setting all the appropriate values in the request URLs as well as abstracting the endpoints of the APIs as functions that return Promises. Note that it is only possible to fetch data after the coreLibrary.init() call has been finished. That means inside its .then() callback. Using Promises Promise is a way to deal with asynchronous (AJAX) requests, it allows for easier chaining and error handling of requests than callbacks. All asynchronous methods of the kambi-widget-core-library return Promises. Promises are Javascript objects and as such they have methods, these methods are then(fn) and catch(fn). Both receive a function as an argument: then(fn) fn called when the Promise is resolved, ie the request has finished successfully. Returns a new Promise catch(fn) fn called when the Promise is reject, ie the request has finished unsuccessfully. Returns a new Promise Both these functions return a new Promise object in a way that allows chaining these methods together Example import { offeringModule } from 'kambi-widget-core-library'; ... var promise = offeringModule.getEvent(someEventId); promise = promise.then(function (response) { console.log('success!'); console.log(response); }); promise = promise.catch(function (error) { // only called if an error happened, for example event not found console.log('error!'); console.log(error); }); // same thing as above, but in a more concise way offeringModule.getEvent(someEventId) .then(function (response) { console.log('success!'); console.log(response); }) .catch(function (error) { // only called if an error happened, for example event not found console.log('error!'); console.log(error); }); Error Handling catch(fn) also catches errors that happen inside previous then(fn) blocks. It is a good practice for Kambi Widget development to make the widget remove itself when an error happens. That means it fails gracefully and does not show in a broken state in the Sportsbook. Example import { offeringModule, widgetModule } from 'kambi-widget-core-library' offeringModule .getLiveEvents() .then(function(response) { if (response.liveEvents.length === 0) { throw new Error('No live events!') } console.log('success!') console.log(response) }) .catch(function(error) { // only called if an error happened console.log('error!') console.log(error) widgetModule.removeWidget() // widget is removed from the Sportsbook }) Chaining Promises It is possible to chain Promises by returning a new Promise inside a then(fn) function, the subsequent then(fn) call will be invoked when this returned Promise is resolved. catch(fn) blocks in the chain will catch any errors that happen before it in the chain. import { offeringModule, widgetModule } from 'kambi-widget-core-library' offeringModule .getLiveEvents() .then(function(response) { if (response.events.length === 0) { throw new Error('No live events!') } // getting the first event betOffers var id = response.events[0].event.id return offeringModule.getLiveEvent(id) // this returns a Promise }) .then(function(response) { console.log(response.betOffers) }) .catch(function(error) { // only called if an error happened in ANY request of the chain console.log('error!') console.log(error) widgetModule.removeWidget() // widget is removed from the Sportsbook }) Parallel Promises Sometimes we want to execute asynchronous calls in parallel for faster data-fetching, to do that we can use Promise.all(promiseArray). It returns a new Promise that is resolved when all Promises inside promiseArray resolve. Example import { offeringModule, widgetModule } from 'kambi-widget-core-library' offeringModule .getLiveEvents() .then(function(response) { if (response.events.length === 0) { throw new Error('No live events!') } // getting all the betOffers of the first event var promises = [] for (var i = 0; i &lt; response.events; i++) { var id = response.events[i].event.id var promise = offeringModule.getLiveEvent(id) promises.push(promise) } return Promise.all(promises) }) .then(function(response) { // will have all the betoffers for all live events console.log(response) }) .catch(function(error) { // only called if an error happened in ANY request of the chain console.log('error!') console.log(error) widgetModule.removeWidget() // widget is removed from the Sportsbook }) More about Promises Offering Module The offeringModule provides data about events, their statuses and their betOffers. It also provides information about the live data for live events. Example getting all live events import { offeringModule } from 'kambi-widget-core-library'; ... offeringModule.getLiveEvents() .then(function(data) { console.log(data); }); Getting all betOffers of a single event import { offeringModule } from 'kambi-widget-core-library'; ... // if it is a pre-live event offeringModule.getEvent(eventId) .then(function(data) { console.log(data); }); // if it is a live event offeringModule.getLiveEvent(eventId) .then(function(data) { console.log(data); }); Making a filter request Filter request are a way to get all the events associated with a filter, filters are strings that define a subset of events. A few examples: football: all football events football/england: all football events from england football/england/premier_league: all football events from the english premier_league tournament football/england/premier_league/arsenal: all football events from the english premier_league in which the Arsenal team is playing football/england/premier_league/all/competitions: all events of type ET_COMPETITON from the premier_league. This excludes actual matches, returning only the overall competition data. For example \"Premier League Group A\", \"Premier League Group B\", \"Premier League\" (the overall tournament). football/england/premier_league/all/matches: all events of type ET_MATCH from the premier_league tournament. This excludes competitions and returns only actual matches. For example: \"Sunderland - Arsenal\", \"Manchester United - Burnley\". Filters also accept a wildcard called all that allows you to skip a certain part of the filter. For example football/all/all is the same as football. Examples import { offeringModule, widgetModule } from 'kambi-widget-core-library'; ... offeringModule.getEventsByFilter('football') .then(function(data) { console.log(data.events); }) offeringModule.getEventsByFilter('football/england/premier_league') .then(function(data) { console.log(data.events); }) // combining two filters offeringModule.getEventsByFilter('football/england,germany') .then(function(data) { console.log(data.events); }) Notes All offering calls that return multiple events (getEventsByFilter for example) also return its main betOffer if it exists. To get ALL betOffers of an event you need to use getEvent(eventId) or getLiveEvent(eventId) depending if the event is live or not. getEventsByFilter returns both live and pre-live matches, it is possible to differentiate between them using eventData.event.openForLiveBetting. If it is true then it the match is live and to get all its betoffers one should use getLiveEvent(eventId) instead of getEvent(eventId) See the offeringModule documentation for a list of all the methods. × Search results Close "},"tutorial-5 - Sportsbook Interaction.html":{"id":"tutorial-5 - Sportsbook Interaction.html","title":"Tutorial: 5 - Sportsbook Interaction","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs 5 - Sportsbook Interaction Interaction with the sportsbook is done through the widgetModule. A few examples of interactions are: changing the widget height, remove the widget from the Sportsbook, adding bets to the betslip. For full documentation please check the widgetModule API documentation. Note: Most of the methods inside the widgetModule only work when the widget is running inside the Sportsbook, when opening the widget as stand-alone these methods don't do anything. Widget Height Since the widgets run inside iframes in the Sportsbook the widget needs to manually control its own height (iframes don't grow in size based in their contents height). The widgetModule provides two ways of changing the widget's height, every time the widget needs to change its height (for example when receiveing new data) one of these methods should be used widgetModule.adaptWidgetHeight() Tries to make the widget the same height as the &lt;body&gt; tag of the page, essentially making the iframe the same size of the widget. This approach doesn't always work, first the &lt;body&gt; tag can not have a 100% height styling rule, secondly this method needs to be called AFTER animations that dynamically change the &lt;body&gt; height end (both CSS animations and Javascript animations have this limitation), which basically means that animations that change the widget's height are not recommended. widgetModule.setHeight(value) Sets the height to a specific value in pixels, this method has no gotchas like the adaptWidgetHeight(), but it can be very cumbersome to keep track of the widgets height manually. Removing the Widget The widget can choose to remove itself from the Sportsbook, this is useful to handle unexpected states in the data (like no events to show) and to prevent the widget from being in a broken state in cases of unexpected errors: // same thing as above in a more concise manner offeringModule.getEvent(someEventId) .then(function (response) { console.log('success!'); console.log(response); }) .catch(function (error) { console.log(error); console.log('Error, maybe the event with the provided id does not exists? Widget removing itself'); widgetModule.removeWidget(); }); Navigating to Other Pages The widgetModule allows the user to redirect the user to other parts of the Sportsbook. Example: widgetModule.navigateToFilter('football/england/premier_league'); Adding Bets to Betslip BetOffers returned from the offeringModule have two or more outcomes (the possible choices in the bet). The widgetModule offers a way to add those outcomes to the betslip. widgetModule.addOutcomeToBetslip(outcome.id); Events The widgetModule offers a publish/subscribe system to listen for a few specific events. For example widgetModule.events.subscribe('ODDS:FORMAT', function() { console.log('odds format changed!'); }); × Search results Close "},"tutorial-6 - Internationalization.html":{"id":"tutorial-6 - Internationalization.html","title":"Tutorial: 6 - Internationalization","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs 6 - Internationalization Translations are handled by the translationModule module which is part of the kambi-widget-core-library. The module fetches the corresponding translations from JSON files inside the src/i18n folder. The use of these files are optional if no internationalization is required. If the user's locale is not found in this folder it will fallback to en_GB.json. These are all the currently supported locales in the Sportsbook, although they can vary by operator: cs_CZ.json, de_DE.json, es_ES.json, fr_CH.json, lt_LT.json, no_NO.json, ro_RO.json, da_DK.json, el_GR.json, et_EE.json, fr_FR.json, lv_LV.json, pl_PL.json, ru_RU.json, de_AT.json, en_AU.json, fi_FI.json, hu_HU.json, nl_BE.json, pt_BR.json, sv_SE.json, de_CH.json, en_GB.json, fr_BE.json, it_IT.json, nl_NL.json, pt_PT.json, tr_TR.json We can test translations by changing the locale parameter in modkSetupData.json. This only works when testing the widget in stand-alone mode (outside of the Kambi Sportsbook). { ... \"clientConfig\": { ... \"locale\": \"en_GB\", ... } } Translating strings To translate a string we use the getTranslation() method of the translationModule import { translationModule } from 'kambi-widget-core-library'; // Translate stadium string document.getElementById('title').innerText(translationModule.getTranslation('Stadium')); On our json files we would have for example sv_SE.json { \"Stadium\": \"Stadion\" } Translation with extra arguments We can also provide arguments when translating. In our json files we can define the number of arguments, so for example: en_GB.json: { \"WelcomeTo\": \"Welcome {0} to {1}\" } sv_SE.json: { \"WelcomeTo\": \"Välkommen {0} till {1}\" } And the translation would be called like so: import { translationModule } from 'kambi-widget-core-library'; var user = 'Jim', place = 'Sportsbook'; // Translate welcome message $('#welcome').text(translationModule.getTranslation('WelcomeTo', user, place)); That would result to Welcome Jim to Sportsbook for 'en_GB' locale and Välkommen Jim till Sportsbook for 'sv_SE' × Search results Close "},"tutorial-7 - Styling.html":{"id":"tutorial-7 - Styling.html","title":"Tutorial: 7 - Styling","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs 7 - Styling Styling should preferably be done by using Kambi classes whenever it is possible possible to keep the style consistent with the rest of the client. Kambi client will load a widgets.css file automatically which will have most of the classes needed to style a widget, matching the operator's theme. These classes have different values depending on the operator or brand, so to make a widget that adapts itself to the operator style these classes should be used exclusively. If the widget is supposed to run in just one operator these classes can be ignored. Note: Kambi uses BEM CSS naming convention Basic CSS classes The CSS classes available by default are: KambiWidget-font Default font that should be used. KambiWidget-primary-color Default color for emphasized text KambiWidget-primary-background-color Default background color for emphasis. KambiWidget-primary-text-color Default color for emphasized text inside emphasized background KambiWidget-card-background-color Default backrgound color for cards KambiWidget-card-background-color--hoverable color when the the user hovers the element with the cursor KambiWidget-card-background-color--clickable color for when the user clicks (or taps) on the element KambiWidget-card-text-color Default font color for text inside cards KambiWidget-card-support-text-color Alternative (secondary) font color for text inside cards KambiWidget-header Default styling (background color, text color and font) used for headers Please note that coreLibrary will add KambiWidget-card-text-color, KambiWidget-card-background-color, KambiWidget-font to the &lt;HTML&gt; tag Here is a screenshot showing various classes in use: × Search results Close "},"tutorial-8 - Using React and widget-components.html":{"id":"tutorial-8 - Using React and widget-components.html","title":"Tutorial: 8 - Using React and widget-components","body":" Kambi Widgets Namespaces widget-components Modules coreLibraryofferingModulestatisticsModuletranslationModuleupdatesModuleutilModulewidgetModule Classes BlendedBackgroundwidget-components.DropdownButtonwidget-components.FixedListwidget-components.Headerwidget-components.OutcomeButtonwidget-components.OutcomeButtonUIwidget-components.ScrolledListwidget-components.TabPagination Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Global FixedList_RenderItemContainerArgsScrolledList_ALIGN_ITEMSScrolledList_RenderButtonArgsScrolledList_RenderItemContainerArgsScrolledList_SCROLL_TO_ITEM_MODETabPagination_RenderTabListArgs 8 - Using React and widget-components Widget-components is a collection of reusable components written with React framework. The use of React and these widget-components is completely optional, but they help a lot in the development and with keeping the style of the widget consistent with the style of the Sportsbook. Pre-requisites You can start using widget-components by installing it as a dependency to the project by running: npm install kamb-wc-widget-components import { ComponentName } from 'kamb-wc-widget-components'; import React from 'react'; import ReactDOM from 'react-dom'; ... ReactDOM.render(reactElement, document.getElementById('root')); ReactDOM.render should only be called after coreLibrary.init() is resolved. You can also make your own components and have the whole widget be a React component if desired, but the components can also be used without using React for the main part of the application. Creating React Elements To render one of the reusable components from kamb-wc-widget-components import { Header } from 'kamb-wc-widget-components' import React from 'react' import ReactDOM from 'react-dom' var header = React.createElement( Header, { collapsable: false }, 'This is the Header title' ) ReactDOM.render(header, document.getElementById('root')) Creating React Elements with JSX JSX is an extension of the normal JavaScript programming language, it adds syntatic sugar to transform HTML code into calls to React.createElement. The following example is equivalent to the previous example: import { Header } from 'kamb-wc-widget-components' import React from 'react' import ReactDOM from 'react-dom' ReactDOM.render( &lt;Header collapsable={false}&gt;This is the Header title&lt;/Header&gt;, document.getElementById('header') ) Note: JSX syntax works only in .jsx files, so index.js should import a .jsx for this syntax to work. The whole widget (except index.js) can be written in .jsx file if so desired. Using React It is possible to use only the pre-made components available in kamb-wc-widget-components, but that is not really recommended. Due to the fact that the widgets live inside iframes it is highly recommended to avoid big dependencies like software frameworks (there will be multiple copies, one for each iframe). It is recommend to either not use any frameworks/libraries (even jQuery is quite big) or use our React solution. Behind the scenes if (and only if) you use React components your project preact will be bundled with the widgets code. This is a very small implementation of the React API (~3 kilobytes vs React ~32kb) and as such its performance impact is minimal. The widget can use React even without including kamb-wc-widget-components, widgets can be written completely as React components if desired, or they can only use the components from kamb-wc-widget-components or not use React at all. useRealReact flag By default the project replaces the normal version of React with preact in production builds only (npm run build). While in development mode though (npm run start) the project uses the real React because it provides more debug functionalities. This is handled by the kambi-widget-core-library automatically. Preact is an alternative implementation of React and as such it can have incompatibilities, although so far we haven't encountered any. If you want to override the default behavior of the build you can force the use of a specific React version by placing a useRealReact object in package.json. You can define different values for development and production environment. package.json: { ... \"useRealReact\": { \"development\": [Boolean], \"production\": [Boolean] } } By default development is true and production is false × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
